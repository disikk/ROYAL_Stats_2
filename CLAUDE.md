# CLAUDE.md

Этот файл предоставляет руководство для Claude Code (claude.ai/code) при работе с кодом в этом репозитории.

## Обзор проекта

Royal Stats — десктопное приложение для отслеживания и анализа статистики турниров по покеру для одного игрока (Hero). Специализируется на отслеживании производительности турниров и статистики нокаутов для турниров Battle Royale/PKO (Progressive Knockout).

Приложение парсит файлы истории рук и сводки турниров для извлечения ключевых метрик и предоставления статистических инсайтов для производительности игрока, с особым акцентом на игру за финальным столом и достигнутые нокауты.

## Настройка и запуск

```bash
# Установка зависимостей
pip install -r requirements.txt

# Запуск приложения
python app.py

# Запуск тестов
python -m unittest discover tests
```

## Ключевые особенности и функциональность

- **Отслеживание турниров**: Записывает ключевую информацию о турнирах, включая бай-ины, выплаты, финишные позиции и количество нокаутов
- **Анализ финального стола**: Специализированное отслеживание производительности финального стола (столы 9-max)
- **Статистика нокаутов**: Детальное отслеживание нокаутов, включая KO ранней стадии финалки и "большие нокауты" (ценные баунти)
- **Управление сессиями**: Группирует турниры в сессии для анализа по периодам
- **Дашборд статистики**: Предоставляет агрегированную статистику по всем турнирам или отфильтрованную по сессиям
- **Распределение мест**: Визуализирует финишные позиции финального стола (1-9)
- **Управление базами данных**: Поддерживает множественные базы данных SQLite для организации данных

## Архитектура и компоненты

Приложение следует принципам чистой архитектуры с событийно-ориентированным подходом:

### 1. Слой UI (`ui/` директория)
- Интерфейс на основе PyQt6 с темной темой по умолчанию
- Паттерн ViewModel для изоляции бизнес-логики от UI
- Все компоненты получают `AppFacade` через конструктор
- UI компоненты только отображают данные из ViewModel

### 2. Слой сервисов (`services/` директория)
- **AppFacade** - единая точка входа для UI слоя
- **ImportService** - изолированная логика импорта файлов
- **StatisticsService** - управление расчетом и кешированием статистики
- **EventBus** - шина событий для слабосвязанной коммуникации
- **AppConfig** - централизованная конфигурация через dataclass

### 3. ViewModel слой (`viewmodels/` директория)
- `StatCardViewModel` - данные для статистических карточек
- `StatsGridViewModel` - полная модель для главного дашборда
- Содержат всю логику форматирования и подготовки данных для UI

### 4. Парсеры (`parsers/` директория)
- Базовый класс `BaseParser` с дженерик интерфейсом
- Типизированные результаты через `HandHistoryResult` и `TournamentSummaryResult`
- `FileClassifier` для определения типа файлов
- Стандартизированный контракт для всех парсеров

### 5. Слой базы данных (`db/` директория)
- `BaseRepository` - базовый класс с общей логикой работы с БД
- Специализированные репозитории с оптимизированными методами
- Составные индексы для производительности
- `DatabaseManager` как синглтон для управления соединениями

### 6. Модули статистики (`stats/` директория)
- Автономные плагины работающие с сырыми данными
- Единая сигнатура `compute()` для всех плагинов
- Поддержка precomputed_stats для оптимизации
- Инкрементальное обновление статистики

### 7. Модели (`models/` директория)
- `BaseModel` - базовый класс с универсальной сериализацией
- Все модели наследуются от BaseModel
- Автоматические методы as_dict/from_dict/update_from_dict

## Схема базы данных

База данных SQLite включает следующие таблицы:
- `sessions`: Записи сессий импорта
- `tournaments`: Данные турниров и результаты
- `hero_final_table_hands`: Детальная информация о руках, сыгранных за финальными столами
- `overall_stats`: Агрегированная статистика по всем турнирам
- `places_distribution`: Распределение финишей финального стола по позициям
- `stat_modules`: Конфигурация для модулей статистики

### Ключевые таблицы:

**tournaments:**
- Объединяет данные из HH и TS файлов
- Ключевые поля: `tournament_id`, `buy_in`, `payout`, `finish_place`, `reached_final_table`
- Отслеживает стеки на старте финалки в фишках и BB

**hero_final_table_hands:**
- Детальные записи каждой раздачи финального стола
- Включает информацию о нокаутах (`hero_ko_this_hand`)
- Флаг ранней стадии финалки (`is_early_final` для 9-6 игроков)

**overall_stats:**
- Агрегированные показатели по всей истории
- Включает "большие KO" по категориям (x1.5, x2, x10, x100, x1000, x10000)
- Статистика ранней стадии финалки

## Специфические требования и определения

- **Hero**: Игрок, чья статистика отслеживается
- **Определение финального стола**: Стол 9-max независимо от уровня блайндов
- **Ранняя стадия финального стола**: Определяется как стадия финального стола с 9-6 игроками
- **Логика обнаружения нокаута**:
  - Игрок считается выбитым Hero, если:
    - Он пошел ва-банк
    - Hero покрывал его (стек Hero ≥ его стек)
    - Hero выиграл банк, в который тот внес вклад
- **Большие нокауты**: Ценные баунти, категоризированные по размеру относительно бай-ина (1.5x, 2x, 10x, 100x, 1000x, 10000x)

## Ключевая конфигурация

Конфигурация централизована в `AppConfig` dataclass (`services/app_config.py`):
- Имя игрока Hero
- Настройки пути к базе данных
- Параметры финального стола и зоны нокаутов
- Конфигурация UI (темная тема по умолчанию)
- Версия приложения: `0.1.0`

AppConfig передается через конструкторы сервисов (Dependency Injection), что исключает глобальные переменные и облегчает тестирование.

## Конвейер обработки данных

1. UI вызывает `AppFacade.import_files()` с выбранными файлами
2. AppFacade делегирует в ImportService
3. ImportService:
   - Классифицирует файлы через FileClassifier
   - Парсит HH файлы → HandHistoryResult
   - Парсит TS файлы → TournamentSummaryResult
   - Объединяет данные по tournament_id
   - Сохраняет через репозитории
   - Публикует DataImportedEvent
4. StatisticsService (реагирует на событие):
   - Выполняет инкрементальное обновление
   - Вызывает автономные стат-плагины
   - Обновляет кеши
   - Публикует StatisticsUpdatedEvent
5. UI обновляется через ViewModel

## Файловая структура

```
├── app.py                  # Точка входа приложения с DI контейнером
├── config.py              # Легаси конфигурация (мигрируется в AppConfig)
├── requirements.txt        # Зависимости Python
├── services/               # Слой сервисов
│   ├── app_facade.py       # Единая точка входа для UI
│   ├── import_service.py   # Логика импорта файлов
│   ├── statistics_service.py # Управление статистикой
│   ├── event_bus.py        # Шина событий
│   ├── events.py           # Определения событий
│   └── app_config.py       # Централизованная конфигурация
├── viewmodels/             # ViewModel слой
│   ├── stat_card.py        # ViewModel для карточек
│   └── stats_grid.py       # ViewModel для дашборда
├── ui/                     # Пользовательский интерфейс
│   ├── main_window.py      # Главное окно (получает AppFacade)
│   ├── stats_grid.py       # Дашборд (использует ViewModel)
│   ├── tournament_view.py  # Представление турниров
│   ├── session_view.py     # Представление сессий
│   └── app_style.py        # Стили и темы
├── db/                     # Слой базы данных
│   ├── manager.py          # Менеджер БД (синглтон)
│   ├── schema.py           # Схема БД с индексами
│   └── repositories/       # Репозитории данных
│       ├── base_repository.py # Базовый класс
│       └── ...             # Специализированные репозитории
├── models/                 # Модели данных
│   ├── base_model.py       # Базовый класс моделей
│   └── ...                 # Dataclass модели
├── parsers/                # Парсеры файлов
│   ├── base_parser.py      # Базовый класс с дженериками
│   ├── parse_results.py    # Типизированные результаты
│   ├── file_classifier.py  # Классификатор файлов
│   └── ...                 # Конкретные парсеры
├── stats/                  # Модули статистики
│   ├── base.py             # Базовый интерфейс
│   └── ...                 # Автономные плагины
└── databases/             # SQLite файлы
```

## Общие задачи разработки

### Добавление нового модуля статистики

1. Создать новый класс в директории `stats/`, расширяющий `BaseStat`
2. Реализовать метод `compute()` с единой сигнатурой
3. Статистика должна работать с сырыми данными (tournaments, hands, sessions)
4. Добавить плагин в список в `StatisticsService`
5. Обновить ViewModel для включения новой статистики

### Добавление или изменение схемы БД

1. Обновить схему в `db/schema.py`
2. Добавить необходимые индексы для производительности
3. Создать репозиторий, наследующийся от `BaseRepository`
4. Создать модель, наследующуюся от `BaseModel`
5. Реализовать метод `_row_to_model` в репозитории
6. Добавить миграцию в `DatabaseManager.initialize_db()` если необходимо
7. Убедиться, что изменения схемы применяются к новым и существующим базам данных

### Расширение парсера

1. Наследоваться от `BaseParser[T]` с указанием типа результата
2. Обновить типизированный результат (HandHistoryResult или TournamentSummaryResult)
3. Реализовать метод `parse()` возвращающий типизированный объект
4. Добавить тесты для новой логики парсинга
5. Обеспечить обратную совместимость с существующими форматами

### Добавление UI компонентов

1. Создать новые компоненты в директории `ui/`
2. Компонент должен получать `AppFacade` через конструктор
3. Создать соответствующий ViewModel в `viewmodels/`
4. UI компонент должен только отображать данные из ViewModel
5. Вся бизнес-логика и форматирование должны быть в ViewModel
6. Использовать AppFacade для всех операций с данными

## Управление состоянием

- `AppFacade` - единая точка входа для всех операций UI
- `EventBus` - координирует обновления между сервисами
- Трехуровневое кеширование статистики (память, БД, файл)
- Инкрементальные обновления для больших баз данных
- Многопоточность для операций импорта с использованием `QThread`

## Особенности реализации

- **Dependency Injection**: Все зависимости передаются через конструкторы
- **Событийная архитектура**: Слабосвязанная коммуникация через EventBus
- **Паттерн ViewModel**: Изоляция бизнес-логики от UI
- **Типобезопасность**: Строгая типизация, включая парсеры и репозитории
- **Инкрементальные обновления**: Оптимизация для больших БД
- **Базовые классы**: BaseModel, BaseRepository, BaseParser для единообразия
- **Ленивая загрузка**: Статистика загружается по требованию
- **Оптимизированные запросы**: Составные индексы и batch операции

## Качество кода и стандарты

- Используйте type hints для всех функций и методов
- Используйте дженерики для типобезопасности (BaseParser[T], BaseRepository[T])
- Наследуйтесь от базовых классов (BaseModel, BaseRepository, BaseParser)
- Передавайте зависимости через конструкторы, избегайте синглтонов
- UI компоненты должны использовать только AppFacade и ViewModel
- Стат-плагины должны быть автономными и работать с сырыми данными
- Следуйте существующим соглашениям именования
- Добавляйте docstrings для всех публичных методов
- Реализуйте правильную обработку ошибок с логированием
- Поддерживайте чистое разделение между слоями архитектуры

## Отладка и логирование

- Логирование настроено в `app.py`
- Используйте уровень `DEBUG` в `config.py` для подробного логирования
- Каждый модуль имеет свой именованный логгер
- Проверяйте логи для диагностики проблем импорта и базы данных