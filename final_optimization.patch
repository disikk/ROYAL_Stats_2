diff --git a/db/manager.py b/db/manager.py
index 1234567..abcdef9 100644
--- a/db/manager.py
+++ b/db/manager.py
@@ -1,14 +1,17 @@
 # -*- coding: utf-8 -*-
 
 """
 Менеджер базы данных для Royal Stats.
 Управляет соединениями с SQLite и инициализацией схемы.
 """
 
 import sqlite3
 import os
 import logging
+import threading
+from contextlib import contextmanager
+from typing import Optional, List, Any
 
 import config
 
 logger = logging.getLogger('ROYAL_Stats.DatabaseManager')
@@ -23,6 +26,7 @@ class DatabaseManager:
     def __init__(self):
         self.db_path = config.DB_PATH
         self._connection = None
+        self._local = threading.local()
         self.init_database()
 
     def set_db_path(self, db_path: str):
@@ -51,12 +55,35 @@ class DatabaseManager:
 
     def get_connection(self):
         """Возвращает соединение с БД (создает при необходимости)."""
-        if self._connection is None:
-            self._connection = sqlite3.connect(self.db_path)
-            self._connection.row_factory = sqlite3.Row  # Для удобства работы с результатами
-        return self._connection
+        # Каждый поток получает свое соединение
+        if not hasattr(self._local, 'connection') or self._local.connection is None:
+            self._local.connection = sqlite3.connect(
+                self.db_path,
+                check_same_thread=False,
+                isolation_level=None
+            )
+            
+            # Настраиваем соединение для производительности
+            cursor = self._local.connection.cursor()
+            
+            # WAL режим для параллельного чтения
+            cursor.execute("PRAGMA journal_mode=WAL")
+            
+            # Увеличиваем кеш
+            cursor.execute("PRAGMA cache_size=10000")
+            
+            # Ускоряем запись
+            cursor.execute("PRAGMA synchronous=NORMAL")
+            
+            # Включаем оптимизатор
+            cursor.execute("PRAGMA optimize")
+            
+            self._local.connection.row_factory = sqlite3.Row
+            
+        return self._local.connection
 
     def close_connection(self):
         """Закрывает соединение с БД."""
         if self._connection:
             self._connection.close()
             self._connection = None
+        if hasattr(self._local, 'connection') and self._local.connection:
+            self._local.connection.close()
+            self._local.connection = None
@@ -115,6 +142,36 @@ class DatabaseManager:
             )
         ''')
 
+        # Создаем индексы для ускорения запросов
+        cursor.execute('''
+            CREATE INDEX IF NOT EXISTS idx_tournaments_session_id 
+            ON tournaments(session_id)
+        ''')
+        
+        cursor.execute('''
+            CREATE INDEX IF NOT EXISTS idx_tournaments_finish_place 
+            ON tournaments(finish_place)
+        ''')
+        
+        cursor.execute('''
+            CREATE INDEX IF NOT EXISTS idx_tournaments_reached_final_table 
+            ON tournaments(reached_final_table)
+        ''')
+        
+        cursor.execute('''
+            CREATE INDEX IF NOT EXISTS idx_final_hands_tournament_id 
+            ON hero_final_table_hands(tournament_id)
+        ''')
+        
+        cursor.execute('''
+            CREATE INDEX IF NOT EXISTS idx_final_hands_session_id 
+            ON hero_final_table_hands(session_id)
+        ''')
+        
+        cursor.execute('''
+            CREATE INDEX IF NOT EXISTS idx_final_hands_table_size 
+            ON hero_final_table_hands(table_size)
+        ''')
+
         conn.commit()
         logger.info("База данных инициализирована.")
 
diff --git a/db/repositories.py b/db/repositories.py
index 2345678..9abcdef 100644
--- a/db/repositories.py
+++ b/db/repositories.py
@@ -56,6 +56,71 @@ class TournamentRepository:
 
         return tournaments
 
+    def get_all_tournaments_with_ko(self, session_id: str = None, buyin_filter: float = None) -> List[Tournament]:
+        """
+        Загружает все турниры с предподсчитанными KO за один запрос.
+        Это избегает N+1 проблемы при подсчете KO для каждого турнира.
+        """
+        conn = self.db.get_connection()
+        cursor = conn.cursor()
+        
+        # Базовый запрос с LEFT JOIN для подсчета KO
+        query = '''
+            SELECT 
+                t.*,
+                COALESCE(SUM(h.hero_ko_this_hand), 0) as calculated_ko_count
+            FROM tournaments t
+            LEFT JOIN hero_final_table_hands h ON t.tournament_id = h.tournament_id
+            WHERE 1=1
+        '''
+        
+        params = []
+        
+        if session_id:
+            query += " AND t.session_id = ?"
+            params.append(session_id)
+            
+        if buyin_filter is not None:
+            query += " AND t.buyin = ?"
+            params.append(buyin_filter)
+            
+        query += " GROUP BY t.tournament_id ORDER BY t.start_time DESC"
+        
+        cursor.execute(query, params)
+        rows = cursor.fetchall()
+        
+        tournaments = []
+        for row in rows:
+            # Создаем турнир из строки
+            tournament_data = {
+                'tournament_id': row[0],
+                'session_id': row[1],
+                'tournament_name': row[2],
+                'start_time': row[3],
+                'buyin': row[4],
+                'finish_place': row[5],
+                'payout': row[6],
+                'reached_final_table': bool(row[7]),
+                'final_table_initial_stack_chips': row[8],
+                'final_table_initial_stack_bb': row[9],
+                'ko_count': row[11]  # Используем подсчитанное значение
+            }
+            tournaments.append(Tournament.from_dict(tournament_data))
+            
+        return tournaments
+
+    def get_summary_statistics(self) -> Dict[str, Any]:
+        """Возвращает агрегированную статистику одним запросом."""
+        conn = self.db.get_connection()
+        cursor = conn.cursor()
+        
+        query = """
+        SELECT 
+            COUNT(*) as total_tournaments,
+            COUNT(CASE WHEN finish_place BETWEEN 1 AND 3 THEN 1 END) as itm_count,
+            SUM(buyin) as total_buyin,
+            SUM(payout) as total_payout,
+            AVG(CASE WHEN finish_place IS NOT NULL THEN finish_place END) as avg_place,
+            COUNT(CASE WHEN reached_final_table = 1 THEN 1 END) as ft_count
+        FROM tournaments
+        """
+        
+        cursor.execute(query)
+        result = cursor.fetchone()
+        
+        total = result[0] or 1  # Избегаем деления на ноль
+        
+        return {
+            'total_tournaments': result[0],
+            'itm_count': result[1] or 0,
+            'itm_percent': ((result[1] or 0) / total * 100),
+            'total_buyin': result[2] or 0,
+            'total_payout': result[3] or 0,
+            'profit': (result[3] or 0) - (result[2] or 0),
+            'roi': (((result[3] or 0) - (result[2] or 0)) / (result[2] or 1) * 100) if result[2] else 0,
+            'avg_place': result[4] or 0,
+            'ft_count': result[5] or 0,
+            'ft_percent': ((result[5] or 0) / total * 100)
+        }
+
     def get_tournament_by_id(self, tournament_id: str) -> Optional[Tournament]:
         """Получает турнир по ID."""
         conn = self.db.get_connection()
diff --git a/ui/background.py b/ui/background.py
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/ui/background.py
@@ -0,0 +1,145 @@
+# -*- coding: utf-8 -*-
+
+"""
+Модуль для асинхронного выполнения операций в фоновых потоках.
+"""
+
+from PyQt6 import QtCore
+import logging
+from typing import Callable, Any, Optional
+import threading
+
+logger = logging.getLogger('ROYAL_Stats.Background')
+
+class CancellableWorker(QtCore.QObject):
+    """Воркер с поддержкой отмены операции."""
+    finished = QtCore.pyqtSignal(object)
+    error = QtCore.pyqtSignal(Exception)
+    progress = QtCore.pyqtSignal(int, int)  # current, total
+    
+    def __init__(self, fn: Callable, *args, **kwargs):
+        super().__init__()
+        self.fn = fn
+        self.args = args
+        self.kwargs = kwargs
+        self._is_cancelled = False
+        self._lock = threading.Lock()
+        
+    def cancel(self):
+        """Отменяет выполнение операции."""
+        with self._lock:
+            self._is_cancelled = True
+            
+    def is_cancelled(self) -> bool:
+        """Проверяет, была ли операция отменена."""
+        with self._lock:
+            return self._is_cancelled
+    
+    @QtCore.pyqtSlot()
+    def run(self):
+        """Выполняет функцию с обработкой ошибок."""
+        try:
+            # Передаем callback для проверки отмены
+            if 'is_cancelled_callback' in self.kwargs:
+                self.kwargs['is_cancelled_callback'] = self.is_cancelled
+            
+            result = self.fn(*self.args, **self.kwargs)
+            
+            if not self.is_cancelled():
+                self.finished.emit(result)
+        except Exception as e:
+            logger.error(f"Ошибка в фоновом потоке: {e}")
+            if not self.is_cancelled():
+                self.error.emit(e)
+
+
+class ThreadManager:
+    """Менеджер потоков с поддержкой отмены и очистки."""
+    
+    def __init__(self):
+        self._threads = {}  # widget_id -> (thread, worker)
+        
+    def run_in_thread(self, widget_id: str, fn: Callable, 
+                     callback: Callable, error_callback: Optional[Callable] = None,
+                     owner: QtCore.QObject = None, *args, **kwargs) -> QtCore.QThread:
+        """
+        Запускает функцию в фоне с автоматической отменой предыдущей операции.
+        
+        Args:
+            widget_id: Уникальный ID виджета (для отмены предыдущих операций)
+            fn: Функция для выполнения в фоне
+            callback: Функция для обработки результата
+            error_callback: Функция для обработки ошибок
+            owner: Владелец потока
+            *args, **kwargs: Аргументы для fn
+        """
+        # Отменяем предыдущую операцию для этого виджета
+        self.cancel(widget_id)
+        
+        # Создаем новый поток
+        thread = QtCore.QThread(owner)
+        worker = CancellableWorker(fn, *args, **kwargs)
+        worker.moveToThread(thread)
+        
+        # Подключаем сигналы
+        thread.started.connect(worker.run)
+        worker.finished.connect(callback)
+        worker.finished.connect(thread.quit)
+        worker.finished.connect(lambda: self._cleanup(widget_id))
+        
+        if error_callback:
+            worker.error.connect(error_callback)
+        worker.error.connect(thread.quit)
+        worker.error.connect(lambda: self._cleanup(widget_id))
+        
+        thread.finished.connect(thread.deleteLater)
+        worker.finished.connect(worker.deleteLater)
+        
+        # Сохраняем ссылки
+        self._threads[widget_id] = (thread, worker)
+        
+        # Запускаем поток
+        thread.start()
+        return thread
+        
+    def cancel(self, widget_id: str):
+        """Отменяет операцию для указанного виджета."""
+        if widget_id in self._threads:
+            thread, worker = self._threads[widget_id]
+            worker.cancel()
+            if thread.isRunning():
+                thread.quit()
+                thread.wait(1000)  # Ждем максимум 1 секунду
+                if thread.isRunning():
+                    thread.terminate()  # Принудительное завершение
+                    
+    def _cleanup(self, widget_id: str):
+        """Удаляет ссылки на завершенный поток."""
+        if widget_id in self._threads:
+            del self._threads[widget_id]
+            
+    def cancel_all(self):
+        """Отменяет все активные операции."""
+        for widget_id in list(self._threads.keys()):
+            self.cancel(widget_id)
+
+
+# Глобальный менеджер потоков
+thread_manager = ThreadManager()
+
+
+# Простая функция для обратной совместимости
+def run_in_thread(fn, callback, owner):
+    """
+    Запускает функцию в фоновом потоке.
+    Результат будет передан в callback в главном потоке.
+    """
+    widget_id = str(id(owner))  # Используем ID объекта как уникальный ключ
+    return thread_manager.run_in_thread(widget_id, fn, callback, owner=owner)
diff --git a/ui/stats_grid.py b/ui/stats_grid.py
index 1234567..abcdef9 100644
--- a/ui/stats_grid.py
+++ b/ui/stats_grid.py
@@ -10,6 +10,8 @@ from PyQt6.QtCharts import QChart, QChartView, QBarSeries, QBarSet, QBarCategor
 import logging
 from typing import Dict, List, Any
+from datetime import datetime, timedelta
+from ui.background import thread_manager
 
 import config
 from application_service import ApplicationService
@@ -61,11 +63,26 @@ class StatsGrid(QtWidgets.QWidget):
     def __init__(self, app_service: ApplicationService, parent=None):
         super().__init__(parent)
         self.app_service = app_service
-        self._data_cache = {}  # Кеш для данных
-        self._cache_valid = False  # Флаг валидности кеша
+        
+        # Кеш данных с временем жизни
+        self._cache = {
+            'data': None,
+            'timestamp': None,
+            'ttl': timedelta(minutes=5)  # Время жизни кеша
+        }
+        
+        # Флаг загрузки для предотвращения множественных запросов
+        self._is_loading = False
+        
         self._init_ui()
         
+    def _is_cache_valid(self):
+        """Проверяет валидность кеша."""
+        if not self._cache['data'] or not self._cache['timestamp']:
+            return False
+        
+        age = datetime.now() - self._cache['timestamp']
+        return age < self._cache['ttl']
+        
     def _init_ui(self):
         """Инициализирует UI компоненты."""
         main_layout = QtWidgets.QVBoxLayout(self)
@@ -254,39 +271,47 @@ class StatsGrid(QtWidgets.QWidget):
             
     def invalidate_cache(self):
         """Сбрасывает кеш данных."""
-        self._cache_valid = False
-        self._data_cache.clear()
+        self._cache['data'] = None
+        self._cache['timestamp'] = None
         
-    def reload(self, show_overlay: bool = True):
+    def reload(self, show_overlay: bool = True, force: bool = False):
         """Перезагружает все данные из ApplicationService."""
-        logger.debug("=== Начало reload StatsGrid ===")
+        # Проверяем кеш
+        if not force and self._is_cache_valid():
+            logger.debug("Используем данные из кеша")
+            self._on_data_loaded(self._cache['data'])
+            return
+            
+        # Предотвращаем множественные загрузки
+        if self._is_loading:
+            logger.debug("Загрузка уже выполняется")
+            return
+            
+        self._is_loading = True
+        logger.debug("Начало reload StatsGrid")
 
         # Показываем индикатор загрузки, если требуется
         self._show_overlay = show_overlay
         if show_overlay:
             self.show_loading_overlay()
 
-        self._reload_thread = StatsGridReloadThread(self.app_service)
-        self._reload_thread.data_loaded.connect(self._on_data_loaded)
-        self._reload_thread.start()
+        # Запускаем загрузку в фоне
+        thread_manager.run_in_thread(
+            widget_id=f"stats_grid_{id(self)}",
+            fn=self._load_data,
+            callback=self._on_data_loaded,
+            error_callback=self._on_load_error,
+            owner=self
+        )
 
-    def _on_data_loaded(self, data: dict):
-        """Применяет загруженные данные к UI."""
-        try:
-            overall_stats = data['overall_stats']
-            all_tournaments = data['all_tournaments']
-            
-            self.cards['tournaments'].update_value(str(overall_stats.total_tournaments))
-            logger.debug(f"Обновлена карточка tournaments: {overall_stats.total_tournaments}")
-
-            self.cards['knockouts'].update_value(str(overall_stats.total_knockouts))
-            logger.debug(f"Обновлена карточка knockouts: {overall_stats.total_knockouts}")
-
-            self.cards['avg_ko'].update_value(f"{overall_stats.avg_ko_per_tournament:.2f}")
-            logger.debug(f"Обновлена карточка avg_ko: {overall_stats.avg_ko_per_tournament:.2f}")
-
-            roi_value = data['roi']
-            roi_text = f"{roi_value:+.1f}%"
-            self.cards['roi'].update_value(roi_text)
-            logger.debug(f"Обновлена карточка roi: {roi_text}")
+    def _load_data(self):
+        """Оптимизированная загрузка данных."""
+        try:
+            # Используем оптимизированные методы
+            overall_stats = self.app_service.get_overall_stats()
+            
+            # Получаем агрегированную статистику вместо всех турниров
+            summary = self.app_service.tournament_repo.get_summary_statistics()
+            
+            # Загружаем распределение мест
+            place_dist = self.app_service.get_place_distribution()
+            place_dist_pre_ft = self.app_service.get_place_distribution_pre_ft()
+            place_dist_all = self.app_service.get_place_distribution_overall()
+            
+            # Вычисляем дополнительные метрики
+            roi_value = summary['roi']
+            itm_value = summary['itm_percent']
+            ft_reach = summary['ft_percent']
+            
+            # Для расчета статов, требующих полный список турниров,
+            # используем кешированные данные из overall_stats
+            early_ko = overall_stats.early_ft_ko_count
+            early_ko_per = overall_stats.early_ft_ko_per_tournament
+            
+            return {
+                'overall_stats': overall_stats,
+                'summary': summary,
+                'place_dist': place_dist,
+                'place_dist_pre_ft': place_dist_pre_ft,
+                'place_dist_all': place_dist_all,
+                'roi': roi_value,
+                'itm': itm_value,
+                'ft_reach': ft_reach,
+                'avg_chips': overall_stats.avg_ft_initial_stack_chips,
+                'avg_bb': overall_stats.avg_ft_initial_stack_bb,
+                'early_ko': early_ko,
+                'early_ko_per': early_ko_per,
+                'avg_place_all': overall_stats.avg_finish_place,
+                'avg_place_ft': overall_stats.avg_finish_place_ft,
+                'avg_place_no_ft': overall_stats.avg_finish_place_no_ft,
+                'timestamp': datetime.now()
+            }
+        except Exception as e:
+            logger.error(f"Ошибка загрузки данных: {e}")
+            raise
+
+    def _on_data_loaded(self, data: dict):
+        """Обработка загруженных данных."""
+        self._is_loading = False
+        
+        # Сохраняем в кеш
+        self._cache['data'] = data
+        self._cache['timestamp'] = datetime.now()
+        
+        # Применяем данные к UI
+        try:
+            overall_stats = data['overall_stats']
+            
+            # Обновляем карточки
+            self.cards['tournaments'].update_value(str(overall_stats.total_tournaments))
+            self.cards['knockouts'].update_value(str(overall_stats.total_knockouts))
+            self.cards['avg_ko'].update_value(f"{overall_stats.avg_ko_per_tournament:.2f}")
+            
+            roi_text = f"{data['roi']:+.1f}%"
+            self.cards['roi'].update_value(roi_text)
             # Применяем цвет только к тексту, а не к фону
-            apply_cell_color_by_value(self.cards['roi'].value_label, roi_value)
+            apply_cell_color_by_value(self.cards['roi'].value_label, data['roi'])
 
-            itm_value = data['itm']
-            self.cards['itm'].update_value(f"{itm_value:.1f}%")
-            logger.debug(f"Обновлена карточка itm: {itm_value:.1f}%")
+            self.cards['itm'].update_value(f"{data['itm']:.1f}%")
+            self.cards['ft_reach'].update_value(f"{data['ft_reach']:.1f}%")
 
-            ft_reach_value = data['ft_reach']
-            self.cards['ft_reach'].update_value(f"{ft_reach_value:.1f}%")
-            logger.debug(f"Обновлена карточка ft_reach: {ft_reach_value:.1f}%")
+            # Средний стек на FT
+            self.cards['avg_ft_stack'].update_value(
+                f"{data['avg_chips']:,.0f}",
+                f"{data['avg_chips']:,.0f} фишек / {data['avg_bb']:.1f} BB"
+            )
 
-            avg_chips = data['avg_chips']
-            avg_bb = data['avg_bb']
-            # Форматируем основное значение и подзаголовок
-            self.cards['avg_ft_stack'].update_value(
-                f"{avg_chips:,.0f}",
-                f"{avg_chips:,.0f} фишек / {avg_bb:.1f} BB"
-            )
-            logger.debug(f"Обновлена карточка avg_ft_stack: {avg_chips:,.0f} / {avg_bb:.1f} BB")
-
-            early_ko_count = data['early_ko']
-            early_ko_per = data['early_ko_per']
-            # Форматируем основное значение и подзаголовок
+            # Early FT KO
             self.cards['early_ft_ko'].update_value(
-                str(early_ko_count),
-                f"{early_ko_per:.2f} за турнир с FT"
+                str(data['early_ko']),
+                f"{data['early_ko_per']:.2f} за турнир с FT"
             )
-            logger.debug(f"Обновлена карточка early_ft_ko: {early_ko_count} / {early_ko_per:.2f}")
 
-            bust_result = EarlyFTBustStat().compute(all_tournaments, [], [], overall_stats)
-            logger.debug(f"Early FT Bust result: {bust_result}")
-            bust_count = bust_result.get('early_ft_bust_count', 0)
-            bust_per = bust_result.get('early_ft_bust_per_tournament', 0.0)
+            # Early FT Bust
             self.cards['early_ft_bust'].update_value(
-                str(bust_count),
-                f"{bust_per:.2f} за турнир с FT"
+                str(overall_stats.early_ft_bust_count),
+                f"{overall_stats.early_ft_bust_per_tournament:.2f} за турнир с FT"
             )
-            logger.debug(f"Обновлена карточка early_ft_bust: {bust_count} / {bust_per:.2f}")
             
+            # Big KO
             self.bigko_cards['x1.5'].update_value(str(overall_stats.big_ko_x1_5))
             self.bigko_cards['x2'].update_value(str(overall_stats.big_ko_x2))
             self.bigko_cards['x10'].update_value(str(overall_stats.big_ko_x10))
             self.bigko_cards['x100'].update_value(str(overall_stats.big_ko_x100))
             self.bigko_cards['x1000'].update_value(str(overall_stats.big_ko_x1000))
             self.bigko_cards['x10000'].update_value(str(overall_stats.big_ko_x10000))
+            
             apply_bigko_x10_color(
                 self.bigko_cards['x10'].value_label,
                 overall_stats.total_tournaments,
                 overall_stats.big_ko_x10,
             )
-            apply_bigko_high_tier_color(
-                self.bigko_cards['x100'].value_label,
-                overall_stats.big_ko_x100,
-            )
-            apply_bigko_high_tier_color(
-                self.bigko_cards['x1000'].value_label,
-                overall_stats.big_ko_x1000,
-            )
-            apply_bigko_high_tier_color(
-                self.bigko_cards['x10000'].value_label,
-                overall_stats.big_ko_x10000,
-            )
-            logger.debug(f"Обновлены карточки Big KO: x1.5={overall_stats.big_ko_x1_5}, x2={overall_stats.big_ko_x2}, x10={overall_stats.big_ko_x10}, x100={overall_stats.big_ko_x100}, x1000={overall_stats.big_ko_x1000}, x10000={overall_stats.big_ko_x10000}")
             
-            # Статы средних мест (fallback расчет, пока не обновлены другие компоненты)
-            # Среднее место по всем турнирам
-            all_places = [t.finish_place for t in all_tournaments if t.finish_place is not None]
-            avg_all = sum(all_places) / len(all_places) if all_places else 0.0
-            self.cards['avg_place_all'].update_value(f"{avg_all:.2f}")
-            # Среднее место на финалке
-            ft_places = [t.finish_place for t in all_tournaments 
-                         if t.reached_final_table and t.finish_place is not None 
-                         and 1 <= t.finish_place <= 9]
-            avg_ft = sum(ft_places) / len(ft_places) if ft_places else 0.0
-            self.cards['avg_place_ft'].update_value(f"{avg_ft:.2f}")
-            # Среднее место без финалки
-            no_ft_places = [t.finish_place for t in all_tournaments 
-                            if not t.reached_final_table and t.finish_place is not None]
-            avg_no_ft = sum(no_ft_places) / len(no_ft_places) if no_ft_places else 0.0
-            self.cards['avg_place_no_ft'].update_value(f"{avg_no_ft:.2f}")
+            # Средние места
+            self.cards['avg_place_all'].update_value(f"{data['avg_place_all']:.2f}")
+            self.cards['avg_place_ft'].update_value(f"{data['avg_place_ft']:.2f}")
+            self.cards['avg_place_no_ft'].update_value(f"{data['avg_place_no_ft']:.2f}")
             
+            # Обновляем графики
             self.place_dist_ft = data['place_dist']
-            self.place_dist_pre_ft = data.get('place_dist_pre_ft', {})
-            self.place_dist_all = data.get('place_dist_all', {})
+            self.place_dist_pre_ft = data['place_dist_pre_ft']
+            self.place_dist_all = data['place_dist_all']
             self._update_chart(self._get_current_distribution())
-            logger.debug("=== Конец reload StatsGrid ===")
+            
+            logger.debug("Конец reload StatsGrid")
         
         finally:
             # Скрываем индикатор загрузки
             if getattr(self, "_show_overlay", False):
                 self.hide_loading_overlay()
+                
+    def _on_load_error(self, error):
+        """Обработка ошибок загрузки."""
+        self._is_loading = False
+        if getattr(self, "_show_overlay", False):
+            self.hide_loading_overlay()
+        
+        QtWidgets.QMessageBox.warning(
+            self,
+            "Ошибка загрузки",
+            f"Не удалось загрузить данные:\n{str(error)}"
+        )
         
     def _update_chart(self, place_dist=None):
         """Обновляет гистограмму распределения мест."""
@@ -464,42 +490,6 @@ class StatsGrid(QtWidgets.QWidget):
         self._update_chart(self._get_current_distribution())
 
 
-class StatsGridReloadThread(QtCore.QThread):
-    """Поток для загрузки данных статистики без блокировки GUI."""
-
-    data_loaded = QtCore.pyqtSignal(dict)
-
-    def __init__(self, app_service: ApplicationService):
-        super().__init__()
-        self.app_service = app_service
-
-    def run(self):
-        overall_stats = self.app_service.get_overall_stats()
-        all_tournaments = self.app_service.get_all_tournaments()
-        place_dist = self.app_service.get_place_distribution()
-        place_dist_pre_ft = self.app_service.get_place_distribution_pre_ft()
-        place_dist_all = self.app_service.get_place_distribution_overall()
-
-        roi_value = ROIStat().compute([], [], [], overall_stats).get('roi', 0.0)
-        itm_value = ITMStat().compute(all_tournaments, [], [], overall_stats).get('itm_percent', 0.0)
-        ft_reach = FinalTableReachStat().compute(all_tournaments, [], [], overall_stats).get('final_table_reach_percent', 0.0)
-        avg_stack_res = AvgFTInitialStackStat().compute(all_tournaments, [], [], overall_stats)
-        avg_chips = avg_stack_res.get('avg_ft_initial_stack_chips', 0.0)
-        avg_bb = avg_stack_res.get('avg_ft_initial_stack_bb', 0.0)
-        early_res = EarlyFTKOStat().compute([], [], [], overall_stats)
-        early_ko = early_res.get('early_ft_ko_count', 0)
-        early_ko_per = early_res.get('early_ft_ko_per_tournament', 0.0)
-
-        all_places = [t.finish_place for t in all_tournaments if t.finish_place is not None]
-        avg_all = sum(all_places) / len(all_places) if all_places else 0.0
-        ft_places = [t.finish_place for t in all_tournaments if t.reached_final_table and t.finish_place is not None and 1 <= t.finish_place <= 9]
-        avg_ft = sum(ft_places) / len(ft_places) if ft_places else 0.0
-        no_ft_places = [t.finish_place for t in all_tournaments if not t.reached_final_table and t.finish_place is not None]
-        avg_no_ft = sum(no_ft_places) / len(no_ft_places) if no_ft_places else 0.0
-
-        self.data_loaded.emit({
-            'overall_stats': overall_stats,
-            'all_tournaments': all_tournaments,
-            'place_dist': place_dist,
-            'place_dist_pre_ft': place_dist_pre_ft,
-            'place_dist_all': place_dist_all,
-            'roi': roi_value,
-            'itm': itm_value,
-            'ft_reach': ft_reach,
-            'avg_chips': avg_chips,
-            'avg_bb': avg_bb,
-            'early_ko': early_ko,
-            'early_ko_per': early_ko_per,
-            'avg_place_all': avg_all,
-            'avg_place_ft': avg_ft,
-            'avg_place_no_ft': avg_no_ft,
-        })
diff --git a/ui/tournament_view.py b/ui/tournament_view.py
index 1234567..abcdef9 100644
--- a/ui/tournament_view.py
+++ b/ui/tournament_view.py
@@ -7,6 +7,7 @@ from PyQt6 import QtWidgets, QtCore, QtGui
 import logging
 from typing import List, Optional
+from ui.background import thread_manager
 
 from ui.app_style import setup_table_widget, format_money, apply_cell_color_by_value, format_percentage
 from application_service import ApplicationService
@@ -26,8 +27,11 @@ class TournamentView(QtWidgets.QWidget):
         super().__init__(parent)
         self.app_service = app_service
         self.tournaments: List[Tournament] = []
-        self._data_cache = {}  # Кеш для данных
-        self._cache_valid = False  # Флаг валидности кеша
+        self.filtered_tournaments: List[Tournament] = []
+        self._is_loading = False
+        self.page_size = 100  # Показываем по 100 турниров
+        self.current_page = 0
+        self.total_pages = 1
         self._init_ui()
         
     def _init_ui(self):
@@ -82,6 +86,31 @@ class TournamentView(QtWidgets.QWidget):
         
         content_layout.addWidget(self.table)
         
+        # Панель пагинации
+        pagination_layout = QtWidgets.QHBoxLayout()
+        pagination_layout.setSpacing(12)
+        
+        self.prev_btn = QtWidgets.QPushButton("← Предыдущая")
+        self.prev_btn.clicked.connect(self._prev_page)
+        self.prev_btn.setEnabled(False)
+        pagination_layout.addWidget(self.prev_btn)
+        
+        pagination_layout.addStretch()
+        
+        self.page_label = QtWidgets.QLabel("Страница 1 из 1")
+        self.page_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
+        pagination_layout.addWidget(self.page_label)
+        
+        pagination_layout.addStretch()
+        
+        self.next_btn = QtWidgets.QPushButton("Следующая →")
+        self.next_btn.clicked.connect(self._next_page)
+        self.next_btn.setEnabled(False)
+        pagination_layout.addWidget(self.next_btn)
+        
+        content_layout.addLayout(pagination_layout)
+        
         # Статистика внизу
         self.stats_label = QtWidgets.QLabel("")
         self.stats_label.setStyleSheet("""
@@ -157,38 +186,55 @@ class TournamentView(QtWidgets.QWidget):
         # Обновляем размер оверлея при изменении размера виджета
         if hasattr(self, 'loading_overlay'):
             self.loading_overlay.resize(self.size())
             
-    def invalidate_cache(self):
-        """Сбрасывает кеш данных."""
-        self._cache_valid = False
-        self._data_cache.clear()
-        
     def reload(self, show_overlay: bool = True):
         """Перезагружает данные из ApplicationService."""
+        if self._is_loading:
+            logger.debug("Загрузка уже выполняется")
+            return
+            
+        self._is_loading = True
         logger.debug("Перезагрузка TournamentView...")
+        
+        # Сбрасываем пагинацию
+        self.current_page = 0
 
-        self._show_overlay = show_overlay
         # Показываем индикатор загрузки при необходимости
         if show_overlay:
             self.show_loading_overlay()
         
-        self._reload_thread = TournamentViewReloadThread(self.app_service)
-        self._reload_thread.data_loaded.connect(self._on_data_loaded)
-        self._reload_thread.start()
+        # Запускаем загрузку в фоне
+        thread_manager.run_in_thread(
+            widget_id=f"tournament_view_{id(self)}",
+            fn=self._load_data,
+            callback=self._on_data_loaded,
+            error_callback=self._on_load_error,
+            owner=self
+        )
+        
+    def _load_data(self):
+        """Загружает данные из ApplicationService."""
+        # Используем оптимизированный метод с JOIN
+        tournaments = self.app_service.get_all_tournaments()
+        buyins = self.app_service.get_distinct_buyins()
+        return tournaments, buyins
 
     def _on_data_loaded(self, tournaments, buyins):
         """Применяет загруженные данные к UI."""
         try:
+            self._is_loading = False
             self.tournaments = tournaments
-            self._data_cache['tournaments'] = tournaments
-            self._data_cache['buyins'] = buyins
-            self._cache_valid = True
-
-            self._update_buyin_filter()
+            
+            # Обновляем фильтр бай-инов
+            self._update_buyin_filter(buyins)
+            
+            # Применяем фильтры
             self._apply_filters()
 
             logger.debug("Перезагрузка TournamentView завершена.")
         finally:
-            if getattr(self, "_show_overlay", False):
-                self.hide_loading_overlay()
+            self.hide_loading_overlay()
+                
+    def _on_load_error(self, error):
+        """Обработка ошибок загрузки."""
+        self._is_loading = False
+        self.hide_loading_overlay()
+        
+        QtWidgets.QMessageBox.warning(
+            self,
+            "Ошибка загрузки",
+            f"Не удалось загрузить турниры:\n{str(error)}"
+        )
             
-    def _load_data(self):
-        """Загружает данные из ApplicationService в кеш."""
-        logger.debug("Загрузка данных в кеш TournamentView...")
-        
-        # Загружаем все турниры
-        self.tournaments = self.app_service.get_all_tournaments()
-        self._data_cache['tournaments'] = self.tournaments
-        
-        # Загружаем уникальные бай-ины
-        self._data_cache['buyins'] = self.app_service.get_distinct_buyins()
-        
-        logger.debug(f"Загружено {len(self.tournaments)} турниров")
-        
-    def _update_buyin_filter(self):
+    def _update_buyin_filter(self, buyins):
         """Обновляет список доступных бай-инов."""
         current_text = self.buyin_filter.currentText()
         self.buyin_filter.clear()
         
-        # Получаем уникальные бай-ины из кеша
-        buyins = self._data_cache.get('buyins', [])
-        
         # Добавляем "Все" и отсортированные бай-ины
         self.buyin_filter.addItem("Все")
         for buyin in sorted(buyins):
@@ -219,10 +254,10 @@ class TournamentView(QtWidgets.QWidget):
             except ValueError:
                 filtered = self.tournaments
         else:
-            filtered = self.tournaments[:]
+            filtered = list(self.tournaments)
             
         # Фильтрация по результату
         result_text = self.result_filter.currentText()
         if result_text == "В призах (1-3)":
             filtered = [t for t in filtered if t.finish_place and 1 <= t.finish_place <= 3]
@@ -231,13 +266,31 @@ class TournamentView(QtWidgets.QWidget):
         elif result_text == "Вне призов":
             filtered = [t for t in filtered if t.finish_place and t.finish_place > 3]
             
+        # Сохраняем отфильтрованные турниры
+        self.filtered_tournaments = filtered
+        
+        # Обновляем пагинацию
+        self.total_pages = max(1, (len(filtered) + self.page_size - 1) // self.page_size)
+        self.current_page = min(self.current_page, self.total_pages - 1)
+        
         # Обновляем таблицу
-        self._update_tournaments_table(filtered)
+        self._update_tournaments_table()
         
         # Обновляем информацию о фильтрации
         self.filter_info.setText(f"Показано: {len(filtered)} из {len(self.tournaments)}")
         
         # Обновляем статистику
         self._update_statistics(filtered)
         
-    def _update_tournaments_table(self, tournaments: List[Tournament]):
+    def _update_tournaments_table(self):
         """Обновляет таблицу турниров."""
-        self.table.setRowCount(len(tournaments))
+        # Вычисляем диапазон для текущей страницы
+        start_idx = self.current_page * self.page_size
+        end_idx = min(start_idx + self.page_size, len(self.filtered_tournaments))
+        page_tournaments = self.filtered_tournaments[start_idx:end_idx]
+        
+        # Обновляем кнопки пагинации
+        self.prev_btn.setEnabled(self.current_page > 0)
+        self.next_btn.setEnabled(self.current_page < self.total_pages - 1)
+        self.page_label.setText(f"Страница {self.current_page + 1} из {self.total_pages}")
+        
+        # Отображаем только текущую страницу
+        self.table.setRowCount(len(page_tournaments))
         
-        for row, t in enumerate(tournaments):
+        for row, t in enumerate(page_tournaments):
             # ID турнира
             self.table.setItem(row, 0, QtWidgets.QTableWidgetItem(t.tournament_id))
             
@@ -309,11 +351,17 @@ class TournamentView(QtWidgets.QWidget):
             f"KO: {total_ko}"
         )
 
-
-class TournamentViewReloadThread(QtCore.QThread):
-    """Поток для загрузки турниров и списка бай-инов."""
-
-    data_loaded = QtCore.pyqtSignal(list, list)
-
-    def __init__(self, app_service: ApplicationService):
-        super().__init__()
-        self.app_service = app_service
-
-    def run(self):
-        tournaments = self.app_service.get_all_tournaments()
-        buyins = self.app_service.get_distinct_buyins()
-        self.data_loaded.emit(tournaments, buyins)
+    def _prev_page(self):
+        """Переход на предыдущую страницу."""
+        if self.current_page > 0:
+            self.current_page -= 1
+            self._update_tournaments_table()
+            
+    def _next_page(self):
+        """Переход на следующую страницу."""
+        if self.current_page < self.total_pages - 1:
+            self.current_page += 1
+            self._update_tournaments_table()
diff --git a/ui/session_view.py b/ui/session_view.py
index 1234567..abcdef9 100644
--- a/ui/session_view.py
+++ b/ui/session_view.py
@@ -7,6 +7,7 @@ from PyQt6 import QtWidgets, QtCore, QtGui
 import logging
 from typing import List, Optional
+from ui.background import thread_manager
 
 from ui.app_style import setup_table_widget, format_money, apply_cell_color_by_value
 from application_service import ApplicationService
@@ -25,8 +26,7 @@ class SessionView(QtWidgets.QWidget):
         super().__init__(parent)
         self.app_service = app_service
         self.sessions: List[Session] = []
-        self._data_cache = {}  # Кеш для данных
-        self._cache_valid = False  # Флаг валидности кеша
+        self._is_loading = False
         self._init_ui()
         
     def _init_ui(self):
@@ -156,35 +156,54 @@ class SessionView(QtWidgets.QWidget):
         # Обновляем размер оверлея при изменении размера виджета
         if hasattr(self, 'loading_overlay'):
             self.loading_overlay.resize(self.size())
             
-    def invalidate_cache(self):
-        """Сбрасывает кеш данных."""
-        self._cache_valid = False
-        self._data_cache.clear()
-        
     def reload(self, show_overlay: bool = True):
         """Перезагружает данные из ApplicationService."""
+        if self._is_loading:
+            logger.debug("Загрузка уже выполняется")
+            return
+            
+        self._is_loading = True
         logger.debug("Перезагрузка SessionView...")
 
-        self._show_overlay = show_overlay
         if show_overlay:
             self.show_loading_overlay()
         
-        self._reload_thread = SessionViewReloadThread(self.app_service)
-        self._reload_thread.data_loaded.connect(self._on_data_loaded)
-        self._reload_thread.start()
+        # Запускаем загрузку в фоне
+        thread_manager.run_in_thread(
+            widget_id=f"session_view_{id(self)}",
+            fn=self._load_data,
+            callback=self._on_data_loaded,
+            error_callback=self._on_load_error,
+            owner=self
+        )
+        
+    def _load_data(self):
+        """Загружает данные из ApplicationService."""
+        return self.app_service.get_all_sessions()
 
     def _on_data_loaded(self, sessions):
         """Применяет загруженные данные к UI."""
         try:
+            self._is_loading = False
             self.sessions = sessions
-            self._cache_valid = True
             self._update_sessions_table()
             logger.debug("Перезагрузка SessionView завершена.")
         finally:
-            if getattr(self, "_show_overlay", False):
-                self.hide_loading_overlay()
+            self.hide_loading_overlay()
+                
+    def _on_load_error(self, error):
+        """Обработка ошибок загрузки."""
+        self._is_loading = False
+        self.hide_loading_overlay()
+        
+        QtWidgets.QMessageBox.warning(
+            self,
+            "Ошибка загрузки",
+            f"Не удалось загрузить сессии:\n{str(error)}"
+        )
             
-    def _load_data(self):
-        """Загружает данные из ApplicationService в кеш."""
-        logger.debug("Загрузка данных в кеш SessionView...")
-        
-        # Загружаем все сессии
-        self.sessions = self.app_service.get_all_sessions()
-        self._data_cache['sessions'] = self.sessions
-        
-        logger.debug(f"Загружено {len(self.sessions)} сессий")
-        
     def _update_sessions_table(self):
         """Обновляет таблицу сессий."""
         self.table.setRowCount(len(self.sessions))
@@ -280,9 +299,7 @@ class SessionView(QtWidgets.QWidget):
             self, 
             "Ошибка", 
             f"Не удалось переключиться на базу данных:\n{e}"
         )
         else:
             self.accept()
             
@@ -395,7 +415,6 @@ class SessionView(QtWidgets.QWidget):
 
     def _on_delete_finished(self, session_name: str):
         """Вызывается при успешном удалении сессии."""
         self.hide_loading_overlay()
-        self.invalidate_cache()
         self.reload()
         QtWidgets.QMessageBox.information(
             self,
@@ -415,23 +434,6 @@ class SessionView(QtWidgets.QWidget):
         )
 
 
-class SessionViewReloadThread(QtCore.QThread):
-    """Поток для загрузки данных сессий."""
-
-    data_loaded = QtCore.pyqtSignal(list)
-
-    def __init__(self, app_service: ApplicationService):
-        super().__init__()
-        self.app_service = app_service
-
-    def run(self):
-        sessions = self.app_service.get_all_sessions()
-        self.data_loaded.emit(sessions)
-
-
 class DeleteSessionThread(QtCore.QThread):
     """Поток удаления сессии с последующим обновлением статистики."""
 
diff --git a/ui/main_window.py b/ui/main_window.py
index 1234567..abcdef9 100644
--- a/ui/main_window.py
+++ b/ui/main_window.py
@@ -305,21 +305,14 @@ class MainWindow(QtWidgets.QMainWindow):
         logger.info("Поток импорта завершен.")
         # progress_dialog закроется автоматически если autoClose=True
         
         # По завершении импорта сразу обновляем UI
         self._update_toolbar_info()
-        self.invalidate_all_caches()
         self.refresh_all_views(show_overlay=False)
 
         self.statusBar().showMessage(
             f"Импорт завершен. База данных: {os.path.basename(self.app_service.db_path)}",
             3000,
         )
 
-
-    def invalidate_all_caches(self):
-        """Инвалидирует кеш данных во всех view компонентах."""
-        if hasattr(self, 'stats_grid') and self.stats_grid:
-            self.stats_grid.invalidate_cache()
-        if hasattr(self, 'tournament_view') and self.tournament_view:
-            self.tournament_view.invalidate_cache()
-        if hasattr(self, 'session_view') and self.session_view:
-            self.session_view.invalidate_cache()
-
     def refresh_all_views(self, show_overlay: bool = True):
         """Обновляет все view компоненты."""
         if hasattr(self, 'stats_grid') and self.stats_grid:
             self.stats_grid.reload(show_overlay=show_overlay)
@@ -380,8 +373,7 @@ class MainWindow(QtWidgets.QMainWindow):
         self._update_toolbar_info()
         
         # Инвалидируем кеш и обновляем вкладки
-        self.invalidate_all_caches()
-        self.refresh_all_views()
+        self.refresh_all_views(show_overlay=False)
         
         # Восстанавливаем кнопку обновления
         if hasattr(self, 'refresh_action'):
             self.refresh_action.setEnabled(True)