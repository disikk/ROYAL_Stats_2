# -*- coding: utf-8 -*-

"""
Сервис приложения Royal Stats.
Содержит основную бизнес-логику, оркестрирует работу парсеров и репозиториев,
подсчитывает агрегированную статистику.
"""

import os
import json
import hashlib
import logging
import uuid
from typing import List, Dict, Any, Optional
from datetime import datetime
import math # Для округления в BB
import re  # Добавить к существующим импортам
import threading

import config
from db.manager import database_manager # Используем синглтон менеджер БД
from db.repositories import (
    TournamentRepository,
    PaginationResult,  # Добавляем импорт для пагинации
    SessionRepository,
    OverallStatsRepository,
    PlaceDistributionRepository,
    FinalTableHandRepository,
)
from parsers import HandHistoryParser, TournamentSummaryParser
from models import Tournament, Session, OverallStats, FinalTableHand
# Импортируем плагины статистик (будут реализованы далее)
from stats import (
    BaseStat, # Базовый класс
    BigKOStat,
    ITMStat,
    ROIStat,
    TotalKOStat,
    AvgKOPerTournamentStat, # Новый
    FinalTableReachStat, # Новый
    AvgFTInitialStackStat, # Новый
    EarlyFTKOStat, # Новый
    EarlyFTBustStat,
    PreFTKOStat,
    AvgFinishPlaceStat,
    AvgFinishPlaceFTStat,
    AvgFinishPlaceNoFTStat,
    FTStackConversionStat,
)

logger = logging.getLogger('ROYAL_Stats.ApplicationService')
logger.setLevel(logging.DEBUG if config.DEBUG else logging.INFO)

# Список плагинов статистик, которые будем использовать
# В реальном приложении можно было бы загружать их динамически
STAT_PLUGINS: List[BaseStat] = [
    TotalKOStat(),
    ITMStat(),
    ROIStat(),
    BigKOStat(),
    AvgKOPerTournamentStat(),
    FinalTableReachStat(),
    AvgFTInitialStackStat(),
    EarlyFTKOStat(),
    EarlyFTBustStat(),
    PreFTKOStat(),
    AvgFinishPlaceStat(),
    AvgFinishPlaceFTStat(),
    AvgFinishPlaceNoFTStat(),
    FTStackConversionStat(),
]

# MOVED TO ImportService: def determine_file_type(file_path: str) -> Optional[str]:
# MOVED TO ImportService:     """
# MOVED TO ImportService:     Определяет тип покерного файла по первым двум строкам.
# MOVED TO ImportService:
# MOVED TO ImportService:     Returns:
# MOVED TO ImportService:         'ts' - Tournament Summary
# MOVED TO ImportService:         'hh' - Hand History
# MOVED TO ImportService:         None - файл не соответствует ожидаемым форматам
# MOVED TO ImportService:     """
# MOVED TO ImportService:     try:
# MOVED TO ImportService:         with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
# MOVED TO ImportService:             lines = f.readlines()
# MOVED TO ImportService:
# MOVED TO ImportService:         # Нужно минимум 2 строки для проверки
# MOVED TO ImportService:         if len(lines) < 2:
# MOVED TO ImportService:             return None
# MOVED TO ImportService:
# MOVED TO ImportService:         first_line = lines[0].strip()
# MOVED TO ImportService:         second_line = lines[1].strip()
# MOVED TO ImportService:
# MOVED TO ImportService:         # Проверка Tournament Summary
# MOVED TO ImportService:         if (first_line.startswith("Tournament #") and
# MOVED TO ImportService:             "Mystery Battle Royale" in first_line and
# MOVED TO ImportService:             second_line.startswith("Buy-in:")):
# MOVED TO ImportService:             return 'ts'
# MOVED TO ImportService:
# MOVED TO ImportService:         # Проверка Hand History
# MOVED TO ImportService:         if (first_line.startswith("Poker Hand #") and
# MOVED TO ImportService:             "Mystery Battle Royale" in first_line and
# MOVED TO ImportService:             second_line.startswith("Table")):
# MOVED TO ImportService:             return 'hh'
# MOVED TO ImportService:
# MOVED TO ImportService:         # Если не подходит ни под один формат
# MOVED TO ImportService:         return None
# MOVED TO ImportService:
# MOVED TO ImportService:     except Exception as e:
# MOVED TO ImportService:         logger.warning(f"Не удалось прочитать файл {file_path}: {e}")
# MOVED TO ImportService:         return None


# MOVED TO ImportService: def is_poker_file(file_path: str) -> bool:
# MOVED TO ImportService:     """
# MOVED TO ImportService:     Предварительная проверка файла - является ли покерным файлом.
# MOVED TO ImportService:     Возвращает True, если файл соответствует ожидаемым форматам.
# MOVED TO ImportService:     """
# MOVED TO ImportService:     return determine_file_type(file_path) is not None

class ApplicationService:
    """
    Центральный сервис приложения.
    """

    def __init__(self):
        self.db = database_manager
        self._tournament_repo = TournamentRepository()
        self.session_repo = SessionRepository()
        self.overall_stats_repo = OverallStatsRepository()
        self.place_dist_repo = PlaceDistributionRepository()
        self.ft_hand_repo = FinalTableHandRepository()

        # Кеш статистики по БД. Ключ - путь к БД, значение - OverallStats
        self._overall_stats_cache: Dict[str, OverallStats] = {}
        # Кеш гистограммы распределения финишных позиций
        self._place_distribution_cache: Dict[str, Dict[int, int]] = {}

        # Файл для сохранения кеша между перезапусками
        self._cache_file = config.STATS_CACHE_FILE
        # Создаём папку для файла кеша, если её ещё нет
        os.makedirs(os.path.dirname(self._cache_file), exist_ok=True)
        self._persistent_cache = self._load_persistent_cache()

        # Блокировка для предотвращения параллельного пересчета статистики
        self._stats_update_lock = threading.Lock()
        self._is_updating_stats = False

        self.hh_parser = HandHistoryParser()
        self.ts_parser = TournamentSummaryParser()

        # Загружаем кэш или создаём его при инициализации сервиса
        self.ensure_overall_stats_cached()

    @property
    def tournament_repo(self):
        """Предоставляет прямой доступ к репозиторию турниров для пагинации."""
        return self._tournament_repo

    @property
    def db_path(self) -> str:
        """Возвращает путь к текущей базе данных."""
        return self.db.db_path

    def get_available_databases(self) -> List[str]:
        """Возвращает список доступных файлов баз данных."""
        return self.db.get_available_databases()

    def switch_database(self, db_path: str, load_stats: bool = True):
        """Переключает активную базу данных."""
        self.db.set_db_path(db_path)
        # После смены БД репозитории автоматически работают с новой БД
        if load_stats:
            # Подгружаем статистику или пересчитываем её при первом подключении
            self.ensure_overall_stats_cached()

    def _compute_db_checksum(self, path: str) -> str:
        """Возвращает MD5-хеш файла БД."""
        try:
            hasher = hashlib.md5()
            with open(path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hasher.update(chunk)
            return hasher.hexdigest()
        except Exception:
            return ""

    def _load_persistent_cache(self) -> Dict[str, Dict[str, Any]]:
        """Загружает кеш статистики из файла."""
        if os.path.exists(self._cache_file):
            try:
                with open(self._cache_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                result = {}
                for db_path, entry in data.items():
                    stats = OverallStats.from_dict(entry.get("overall_stats", {}))
                    distribution = {int(k): int(v) for k, v in entry.get("place_distribution", {}).items()}
                    result[db_path] = {
                        "checksum": entry.get("checksum", ""),
                        "overall_stats": stats,
                        "place_distribution": distribution,
                    }
                return result
            except Exception as e:
                logger.warning(f"Не удалось загрузить кеш статистики: {e}")
        else:
            # Если файла нет, убеждаемся, что директория существует
            os.makedirs(os.path.dirname(self._cache_file), exist_ok=True)
        return {}

    def _save_persistent_cache(self) -> None:
        """Сохраняет кеш статистики в файл."""
        data = {}
        for db_path, entry in self._persistent_cache.items():
            data[db_path] = {
                "checksum": entry.get("checksum", ""),
                "overall_stats": entry.get("overall_stats", OverallStats()).as_dict(),
                "place_distribution": entry.get("place_distribution", {i: 0 for i in range(1, 10)}),
            }
        try:
            os.makedirs(os.path.dirname(self._cache_file), exist_ok=True)
            with open(self._cache_file, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.warning(f"Не удалось сохранить кеш статистики: {e}")

    def ensure_overall_stats_cached(self, progress_callback=None) -> None:
        """Гарантирует наличие кешированных статистик для текущей БД."""
        db_path = self.db.db_path
        if db_path in self._overall_stats_cache and db_path in self._place_distribution_cache:
            return

        # Проверяем, не идет ли уже пересчет
        with self._stats_update_lock:
            if self._is_updating_stats:
                logger.debug("Пересчет статистики уже идет, пропускаем")
                return
            self._is_updating_stats = True

        try:
            checksum = self._compute_db_checksum(db_path)
            cached = self._persistent_cache.get(db_path)
            if cached and cached.get("checksum") == checksum:
                self._overall_stats_cache[db_path] = cached.get("overall_stats", OverallStats())
                self._place_distribution_cache[db_path] = cached.get("place_distribution", {i: 0 for i in range(1, 10)})
                logger.debug("Используется сохранённый кэш статистики")
                return
            logger.debug("Кэш не найден или устарел, пересчёт статистики")

            # Проверяем, есть ли данные в таблице турниров
            count = self.db.execute_query("SELECT COUNT(*) AS c FROM tournaments")
            tournaments_num = count[0][0] if count else 0

            if tournaments_num > 0:
                # Если база не пуста и статистика ещё не рассчитана, пересчитываем
                # НО! Проверяем, есть ли уже статистика в БД
                existing_stats = self.overall_stats_repo.get_overall_stats()
                if existing_stats and existing_stats.total_tournaments > 0:
                    # Используем существующую статистику из БД
                    logger.debug("Используется существующая статистика из БД")
                    self._overall_stats_cache[db_path] = existing_stats
                    distribution = self.place_dist_repo.get_distribution()
                    self._place_distribution_cache[db_path] = distribution
                    return
                else:
                    # Только если статистики нет, запускаем пересчет
                    logger.debug("Статистика отсутствует, запускаем пересчет")
                    self._update_all_statistics("", progress_callback=progress_callback)
            else:
                # Пустая база — статистика нулевая
                self.overall_stats_repo.update_overall_stats(OverallStats())

            # Загружаем статистику из БД и кладём в кеш и файл
            stats = self.overall_stats_repo.get_overall_stats()
            distribution = self.place_dist_repo.get_distribution()
            self._overall_stats_cache[db_path] = stats
            self._place_distribution_cache[db_path] = distribution
            self._persistent_cache[db_path] = {
                "checksum": checksum,
                "overall_stats": stats,
                "place_distribution": distribution,
            }
            self._save_persistent_cache()

        finally:
            # Освобождаем флаг
            with self._stats_update_lock:
                self._is_updating_stats = False

    def create_new_database(self, db_name: str):
        """Создает новую базу данных и переключается на нее."""
        # DatabaseManager сам создаст папку, если нужно, и инициализирует схему
        new_db_path = os.path.join(config.DEFAULT_DB_DIR, db_name)
        if not new_db_path.lower().endswith(".db"):
            new_db_path += ".db"

        if os.path.exists(new_db_path):
            logger.warning(f"Попытка создать существующую БД: {new_db_path}")
            # Можно вернуть False или пробросить исключение, чтобы UI показал ошибку
            raise FileExistsError(f"База данных '{os.path.basename(new_db_path)}' уже существует.")

        self.db.set_db_path(new_db_path)  # Устанавливаем новый путь

        # Принудительно открываем соединение, чтобы физически создать файл БД
        # и инициализировать схему. Иначе файл появится только при первом
        # обращении к данным, что мешает отображению новой БД в диалоге.
        conn = self.db.get_connection()
        self.db.close_connection()

        logger.info(f"Создана и выбрана новая база данных: {new_db_path}")

    def rename_database(self, old_path: str, new_name: str) -> str:
        """Переименовывает файл базы данных."""
        directory = os.path.dirname(old_path)
        new_path = os.path.join(directory, new_name)
        if not new_path.lower().endswith(".db"):
            new_path += ".db"

        if os.path.exists(new_path):
            raise FileExistsError(
                f"База данных '{os.path.basename(new_path)}' уже существует."
            )

        # Закрываем соединение перед переименованием
        self.db.close_all_connections()
        os.rename(old_path, new_path)

        # Обновляем кеши статистики
        if old_path in self._overall_stats_cache:
            self._overall_stats_cache[new_path] = self._overall_stats_cache.pop(old_path)
        if old_path in self._place_distribution_cache:
            self._place_distribution_cache[new_path] = self._place_distribution_cache.pop(old_path)
        if old_path in self._persistent_cache:
            self._persistent_cache[new_path] = self._persistent_cache.pop(old_path)
            self._save_persistent_cache()

        if self.db.db_path == old_path:
            self.switch_database(new_path, load_stats=False)

        return new_path

    def import_files(self, *args, **kwargs):
        # This method has been moved to ImportService
        logger.error("import_files called on ApplicationService. It has been moved to ImportService.")
        raise NotImplementedError("import_files has been moved to ImportService")

    def _update_all_statistics(self, session_id: str, progress_callback=None):
        """
        Пересчитывает и обновляет все агрегированные статистики (общие и по сессии).
        Вызывается после импорта данных.
        """

        # Предварительно загружаем данные для оценки объема работы
        all_tournaments = self.tournament_repo.get_all_tournaments()
        all_final_tournaments = [
            t for t in all_tournaments
            if t.reached_final_table and t.finish_place is not None and 1 <= t.finish_place <= 9
        ]
        sessions_to_update = self.session_repo.get_all_sessions()

        # Общее количество операций для прогресса
        total_steps = 1 + len(all_final_tournaments) + len(all_tournaments) + len(sessions_to_update)
        current_step = 0

        # --- Обновление Overall Stats ---
        try:
            if progress_callback:
                progress_callback(current_step, total_steps, "Обновление общей статистики...")
            overall_stats = self._calculate_overall_stats()
            self.overall_stats_repo.update_overall_stats(overall_stats)
            # Обновляем кеш для текущей БД
            self._overall_stats_cache[self.db.db_path] = overall_stats
            logger.debug("Общая статистика обновлена успешно.")
            current_step += 1
            if progress_callback:
                progress_callback(current_step, total_steps, "Общая статистика обновлена")
        except Exception as e:
            logger.error(f"Ошибка при обновлении overall_stats: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

        # --- Обновление Place Distribution ---
        try:
            new_distribution = {i: 0 for i in range(1, 10)}
            for tourney in all_final_tournaments:
                new_distribution[tourney.finish_place] += 1
                current_step += 1
                if progress_callback:
                    progress_callback(current_step, total_steps, f"Обновлено мест: {current_step-1}/{len(all_final_tournaments)}")
            self.place_dist_repo.update_distribution(new_distribution)
            logger.debug(
                f"Распределение мест обновлено для {len(all_final_tournaments)} турниров."
            )
        except Exception as e:
            logger.error(f"Ошибка при обновлении place_distribution: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

        # --- Обновление KO count для турниров ---
        try:
            for tournament in all_tournaments:
                tournament_ft_hands = self.ft_hand_repo.get_hands_by_tournament(tournament.tournament_id)
                total_ko = sum(hand.hero_ko_this_hand for hand in tournament_ft_hands)
                tournament.ko_count = total_ko
                self.tournament_repo.add_or_update_tournament(tournament)
                current_step += 1
                if progress_callback:
                    progress_callback(current_step, total_steps, f"Обновлено турниров: {current_step - 1 - len(all_final_tournaments)}/{len(all_tournaments)}")
            logger.debug(
                f"KO count обновлен для {len(all_tournaments)} турниров."
            )
        except Exception as e:
            logger.error(f"Ошибка при обновлении ko_count: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

        # --- Обновление Session Stats ---
        try:
            for session in sessions_to_update:
                try:
                    self._calculate_and_update_session_stats(session.session_id)
                except Exception as e:
                    logger.error(f"Ошибка при обновлении сессии {session.session_id}: {e}")
                current_step += 1
                if progress_callback:
                    progress_callback(current_step, total_steps, f"Обновлено сессий: {current_step - 1 - len(all_final_tournaments) - len(all_tournaments)}/{len(sessions_to_update)}")
            logger.debug(
                f"Статистика обновлена для {len(sessions_to_update)} сессий."
            )
        except Exception as e:
            logger.error(f"Ошибка при обновлении session stats: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

        if progress_callback:
            progress_callback(total_steps, total_steps, "Статистика обновлена")

        logger.info("Обновление всей статистики завершено (с учетом возможных ошибок).")

        # Сохраняем обновленную статистику в файл кеша
        checksum = self._compute_db_checksum(self.db.db_path)
        current_stats = self._overall_stats_cache.get(self.db.db_path, OverallStats())
        current_dist = self.place_dist_repo.get_distribution()
        self._place_distribution_cache[self.db.db_path] = current_dist
        self._persistent_cache[self.db.db_path] = {
            "checksum": checksum,
            "overall_stats": current_stats,
            "place_distribution": current_dist,
        }
        self._save_persistent_cache()


    def _calculate_overall_stats(self) -> OverallStats:
        """
        Рассчитывает все показатели для OverallStats на основе данных из БД.
        """
        all_tournaments = self.tournament_repo.get_all_tournaments()
        all_ft_hands = self.ft_hand_repo.get_all_hands() # Все руки финалок
        logger.debug(
            f"_calculate_overall_stats: Загружено {len(all_tournaments)} турниров"
        )
        logger.debug(
            f"_calculate_overall_stats: Загружено {len(all_ft_hands)} рук финального стола"
        )
        # Проверяем содержимое первого турнира для отладки
        if all_tournaments:
            t = all_tournaments[0]

        stats = OverallStats() # Создаем объект с дефолтными значениями

        stats.total_tournaments = len(all_tournaments)

        # Фильтруем турниры, достигшие финального стола
        final_table_tournaments = [t for t in all_tournaments if t.reached_final_table]
        stats.total_final_tables = len(final_table_tournaments)

        # Расчеты, основанные на турнирах:
        stats.total_buy_in = sum(t.buyin for t in all_tournaments if t.buyin is not None)
        stats.total_prize = sum(t.payout if t.payout is not None else 0 for t in all_tournaments)

        # Среднее место по всем турнирам (включая не финалку)
        all_places = [t.finish_place for t in all_tournaments if t.finish_place is not None]
        stats.avg_finish_place = sum(all_places) / len(all_places) if all_places else 0.0

        # Среднее место только на финалке (1-9)
        ft_places = [t.finish_place for t in final_table_tournaments if t.finish_place is not None and 1 <= t.finish_place <= 9]
        stats.avg_finish_place_ft = sum(ft_places) / len(ft_places) if ft_places else 0.0

        # Общее количество KO - суммируем hero_ko_this_hand из всех рук финального стола
        # Обновленный HandHistoryParser точно определяет выбывших игроков путем сравнения
        # списков игроков между соседними раздачами в хронологическом порядке
        stats.total_knockouts = sum(hand.hero_ko_this_hand for hand in all_ft_hands)
        logger.debug(f"Рассчитано total_knockouts: {stats.total_knockouts}")

        # Avg KO / Tournament (по всем турнирам, включая не финалку)
        stats.avg_ko_per_tournament = stats.total_knockouts / stats.total_tournaments if stats.total_tournaments > 0 else 0.0

        # % Reach FT
        stats.final_table_reach_percent = (stats.total_final_tables / stats.total_tournaments * 100) if stats.total_tournaments > 0 else 0.0


        # Средний стек на старте финалки (чипсы и BB)
        ft_initial_stacks_chips = [t.final_table_initial_stack_chips for t in final_table_tournaments if t.final_table_initial_stack_chips is not None]
        stats.avg_ft_initial_stack_chips = sum(ft_initial_stacks_chips) / len(ft_initial_stacks_chips) if ft_initial_stacks_chips else 0.0

        ft_initial_stacks_bb = [t.final_table_initial_stack_bb for t in final_table_tournaments if t.final_table_initial_stack_bb is not None]
        stats.avg_ft_initial_stack_bb = sum(ft_initial_stacks_bb) / len(ft_initial_stacks_bb) if ft_initial_stacks_bb else 0.0

        # Расчеты для "ранней стадии финалки" (9-6 игроков)
        early_ft_hands = [hand for hand in all_ft_hands if hand.is_early_final]
        stats.early_ft_ko_count = sum(hand.hero_ko_this_hand for hand in early_ft_hands)

        # Среднее KO в ранней финалке на турнир (считаем только для турниров, достигших финалки)
        stats.early_ft_ko_per_tournament = stats.early_ft_ko_count / stats.total_final_tables if stats.total_final_tables > 0 else 0.0

        # Вылеты Hero на ранней стадии финалки (6-9 место)
        stats.early_ft_bust_count = sum(
            1
            for t in final_table_tournaments
            if t.finish_place is not None and 6 <= t.finish_place <= 9
        )
        stats.early_ft_bust_per_tournament = (
            stats.early_ft_bust_count / stats.total_final_tables if stats.total_final_tables > 0 else 0.0
        )

        # Финальные столы, начавшиеся неполным составом
        first_ft_hands: dict[str, FinalTableHand] = {}
        for hand in all_ft_hands:
            if hand.table_size == config.FINAL_TABLE_SIZE:
                saved = first_ft_hands.get(hand.tournament_id)
                if saved is None or hand.hand_number < saved.hand_number:
                    first_ft_hands[hand.tournament_id] = hand

        stats.incomplete_ft_count = sum(
            1 for h in first_ft_hands.values() if h.players_count < config.FINAL_TABLE_SIZE
        )

        # KO в последней 5-max раздаче перед финальным столом
        stats.pre_ft_ko_count = sum(hand.pre_ft_ko for hand in all_ft_hands)

        # Логируем статистику по выплатам для отладки
        tournaments_with_payout = sum(1 for t in all_tournaments if t.payout is not None and t.payout > 0)
        tournaments_without_payout = sum(1 for t in all_tournaments if t.payout is None or t.payout == 0)
        logger.debug(
            f"Турниры с выплатами: {tournaments_with_payout}, без выплат: {tournaments_without_payout}"
        )

        # Логируем примеры турниров с выплатами для отладки Big KO
        tournaments_with_big_payout = [t for t in all_tournaments
                                      if t.payout is not None and t.payout > 0 and t.buyin is not None
                                      and t.payout >= t.buyin * 10]
        if tournaments_with_big_payout:
            logger.debug(
                f"Найдено {len(tournaments_with_big_payout)} турниров с выплатой >= 10x buyin:"
            )
            for t in tournaments_with_big_payout[:5]:  # Показываем первые 5
                logger.debug(
                    f"  - Турнир {t.tournament_id}: место {t.finish_place}, "
                    f"buyin=${t.buyin}, payout=${t.payout} "
                    f"(ratio: {t.payout/t.buyin:.1f}x)"
                )

        # Расчет Big KO (требует buyin и payout из турниров)
        big_ko_results = BigKOStat().compute(all_tournaments, all_ft_hands, [], None)
        logger.debug(f"BigKO результаты: {big_ko_results}")
        stats.big_ko_x1_5 = big_ko_results.get("x1.5", 0)
        stats.big_ko_x2 = big_ko_results.get("x2", 0)
        stats.big_ko_x10 = big_ko_results.get("x10", 0)
        stats.big_ko_x100 = big_ko_results.get("x100", 0)
        stats.big_ko_x1000 = big_ko_results.get("x1000", 0)
        stats.big_ko_x10000 = big_ko_results.get("x10000", 0)


        # Среднее место когда НЕ дошел до финалки
        no_ft_places = [t.finish_place for t in all_tournaments
                       if not t.reached_final_table and t.finish_place is not None]
        stats.avg_finish_place_no_ft = sum(no_ft_places) / len(no_ft_places) if no_ft_places else 0.0
        stats.avg_finish_place_no_ft = round(stats.avg_finish_place_no_ft, 2)

        # Можно округлить некоторые значения для хранения
        stats.avg_finish_place = round(stats.avg_finish_place, 2)
        stats.avg_finish_place_ft = round(stats.avg_finish_place_ft, 2)
        stats.avg_ko_per_tournament = round(stats.avg_ko_per_tournament, 2)
        stats.avg_ft_initial_stack_chips = round(stats.avg_ft_initial_stack_chips, 2)
        stats.avg_ft_initial_stack_bb = round(stats.avg_ft_initial_stack_bb, 2)
        stats.early_ft_ko_per_tournament = round(stats.early_ft_ko_per_tournament, 2)
        stats.early_ft_bust_per_tournament = round(stats.early_ft_bust_per_tournament, 2)
        stats.final_table_reach_percent = round(stats.final_table_reach_percent, 2)
        stats.pre_ft_ko_count = round(stats.pre_ft_ko_count, 2)

        logger.debug(
            f"Итоговая статистика: tournaments={stats.total_tournaments}, knockouts={stats.total_knockouts}, prize={stats.total_prize}, buyin={stats.total_buy_in}"
        )
        return stats

    def _calculate_and_update_session_stats(self, session_id: str):
        """
        Рассчитывает и обновляет статистику для конкретной сессии.
        """
        session = self.session_repo.get_session_by_id(session_id)
        if not session:
            logger.warning(f"Сессия с ID {session_id} не найдена для обновления статистики.")
            return

        tournaments_in_session = self.tournament_repo.get_all_tournaments(session_id=session_id)
        ft_hands_in_session = self.ft_hand_repo.get_hands_by_session(session_id=session_id)


        session.tournaments_count = len(tournaments_in_session)
        session.knockouts_count = sum(hand.hero_ko_this_hand for hand in ft_hands_in_session)

        # Среднее место по всем турнирам в сессии
        all_places_session = [t.finish_place for t in tournaments_in_session if t.finish_place is not None]
        session.avg_finish_place = sum(all_places_session) / len(all_places_session) if all_places_session else 0.0

        session.total_prize = sum(t.payout for t in tournaments_in_session if t.payout is not None)
        session.total_buy_in = sum(t.buyin for t in tournaments_in_session if t.buyin is not None)

        # Округляем значения
        session.avg_finish_place = round(session.avg_finish_place, 2)
        session.total_prize = round(session.total_prize, 2)
        session.total_buy_in = round(session.total_buy_in, 2)

        self.session_repo.update_session_stats(session)


    # --- Методы для получения данных для UI ---

    def get_overall_stats(self) -> OverallStats:
        """Возвращает объект OverallStats с общей статистикой."""
        self.ensure_overall_stats_cached()
        return self._overall_stats_cache.get(self.db.db_path, OverallStats())

    def get_all_tournaments(self, buyin_filter: Optional[float] = None) -> List[Tournament]:
        """Возвращает список всех турниров Hero, опционально фильтруя по бай-ину."""
        return self.tournament_repo.get_all_tournaments(buyin_filter=buyin_filter)

    def get_all_sessions(self) -> List[Session]:
        """Возвращает список всех сессий Hero."""
        return self.session_repo.get_all_sessions()

    def get_place_distribution(self) -> Dict[int, int]:
        """Возвращает распределение мест на финальном столе (1-9)."""
        self.ensure_overall_stats_cached()
        return self._place_distribution_cache.get(
            self.db.db_path,
            self.place_dist_repo.get_distribution(),
        )

    def get_place_distribution_pre_ft(self) -> Dict[int, int]:
        """Возвращает распределение мест до финального стола (10-18)."""
        tournaments = self.tournament_repo.get_all_tournaments()
        distribution = {i: 0 for i in range(10, 19)}
        for tourney in tournaments:
            if tourney.finish_place is not None and 10 <= tourney.finish_place <= 18:
                distribution[tourney.finish_place] += 1
        return distribution

    def get_place_distribution_overall(self) -> Dict[int, int]:
        """Возвращает распределение мест по всем турнирам (1-18)."""
        tournaments = self.tournament_repo.get_all_tournaments()
        distribution = {i: 0 for i in range(1, 19)}
        for tourney in tournaments:
            if tourney.finish_place is not None and 1 <= tourney.finish_place <= 18:
                distribution[tourney.finish_place] += 1
        return distribution

    def get_distinct_buyins(self) -> List[float]:
        """Возвращает список уникальных бай-инов из сохраненных турниров."""
        return self.tournament_repo.get_distinct_buyins()

    # Методы для получения данных сессии для отображения стат по сессии
    def get_session_stats(self, session_id: str) -> Optional[Session]:
        """Возвращает объект Session с агрегированной статистикой для указанной сессии."""
        return self.session_repo.get_session_by_id(session_id)

    def get_place_distribution_for_session(self, session_id: str) -> Dict[int, int]:
         """
         Рассчитывает и возвращает распределение мест (1-9) только для турниров в указанной сессии.
         """
         tournaments_in_session = self.tournament_repo.get_all_tournaments(session_id=session_id)
         distribution = {i: 0 for i in range(1, 10)}
         total_final_tables_in_session = 0

         for tourney in tournaments_in_session:
              if tourney.reached_final_table:
                   total_final_tables_in_session += 1 # Count FTs for this session
                   if tourney.finish_place is not None and 1 <= tourney.finish_place <= 9:
                        distribution[tourney.finish_place] += 1

         # Возвращаем распределение и общее количество финалок в сессии для нормализации в UI
         return distribution, total_final_tables_in_session

    def delete_session(self, session_id: str):
        """Удаляет сессию и все связанные данные."""
        # Удаляем сессию (каскадное удаление удалит связанные турниры и руки)
        self.session_repo.delete_session_by_id(session_id)
        # Статистика пересчитывается асинхронно во внешнем потоке

    def rename_session(self, session_id: str, new_name: str):
        """Переименовывает сессию."""
        self.session_repo.update_session_name(session_id, new_name)

    def delete_tournament(self, tournament_id: str):
        """Удаляет турнир и связанные с ним данные."""
        self.tournament_repo.delete_tournament_by_id(tournament_id)


# Создаем синглтон экземпляр ApplicationService
application_service = ApplicationService()

[end of application_service.py]
