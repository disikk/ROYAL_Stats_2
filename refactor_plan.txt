
### Комплексный План Рефакторинга Архитектуры Royal Stats

Цель этого плана — преобразовать текущую архитектуру в высокомодульную, гибкую и легко расширяемую систему, устранив смешение ответственностей и дублирование кода.

### 1. Фундаментальные Архитектурные Изменения

#### 1.1. Декомпозиция `ApplicationService` на сфокусированные сервисы

*   **Описание проблемы:** Класс `ApplicationService` является "божественным объектом", отвечающим за импорт, статистику, кэш и управление БД. Это нарушает Принцип единственной ответственности (SRP), усложняет код и его тестирование.
*   **Цель:** Разделить `ApplicationService` на несколько сервисов с четко определенными обязанностями, улучшив модульность и читаемость.
*   **Задача:**
    1.  Создать класс `ImportService`, отвечающий только за процесс импорта файлов: координацию работы `FileClassifier` и парсеров, а также сохранение "сырых" данных в БД через репозитории.
    2.  Создать класс `StatisticsService`, отвечающий за расчет всех статистических показателей (глобальных и сессионных) путем вызова стат-плагинов, а также за управление кэшем статистики.
    3.  Превратить `ApplicationService` в тонкий фасад (`AppFacade`), который координирует вызовы к другим сервисам и является единственной точкой входа для UI, но не содержит сложной бизнес-логики.

#### 1.2. Внедрение Шины Событий (Event Bus) для слабой связанности

*   **Описание проблемы:** Компоненты (сервисы, UI) жестко связаны друг с другом через прямые вызовы. Например, после импорта нужно явно вызвать обновление статистики, а затем обновить UI. Это создает цепочки зависимостей, которые усложняют добавление новой функциональности.
*   **Цель:** Полностью разделить компоненты, позволив им реагировать на события в системе, не зная о существовании друг друга. Это ключ к максимальной модульности и гибкости.
*   **Задача:**
    1.  Реализовать простую Шину Событий (Event Bus). Это может быть синглтон, который позволяет подписываться на события и публиковать их.
    2.  Изменить сервисы для работы через события. Например:
        *   `ImportService` после завершения импорта публикует событие `DataImportedEvent`, содержащее ID новых/обновленных турниров.
        *   `StatisticsService` подписывается на `DataImportedEvent` и, получив его, запускает пересчет статистики (инкрементальный) только для затронутых данных.
        *   UI-компоненты (`StatsGrid`, `TournamentView`) также подписываются на `DataImportedEvent` и/или `StatisticsUpdatedEvent` и обновляют свое состояние.

#### 1.3. Инверсия Зависимостей и Конфигурирование

*   **Описание проблемы:** Компоненты напрямую импортируют зависимости и читают настройки из глобального `config.py`. Это затрудняет тестирование (нельзя подменить зависимость) и изменение конфигурации без правки кода.
*   **Цель:** Сделать зависимости явными и внедрять их извне. Централизовать конфигурацию приложения.
*   **Задача:**
    1.  Создать `dataclass AppConfig` для хранения всех настроек (пути, имя Hero и т.д.).
    2.  В точке входа приложения (`app.py`) создать экземпляр `AppConfig` и экземляры всех сервисов.
    3.  Передавать все необходимые зависимости (другие сервисы, `database_manager`, `AppConfig`) в конструкторы классов (`__init__`), а не импортировать их внутри.

### 2. Реорганизация Логики Расчета Статистики

#### 2.1. Усиление роли и автономности Стат-плагинов

*   **Описание проблемы:** Стат-плагины частично зависят от предварительно рассчитанного объекта `OverallStats`, а часть логики расчета находится вне плагинов. Это приводит к дублированию и ограничивает переиспользование плагинов для расчета статистики по срезам данных (например, по одной сессии).
*   **Цель:** Сделать каждый стат-плагин полностью автономным калькулятором, который не зависит от других расчетов.
*   **Задача:**
    1.  Переработать базовый класс `BaseStat` и все его наследники. Метод `compute` должен принимать на вход только "сырые" данные (например, `List[Tournament]`, `List[FinalTableHand]`) и самостоятельно выполнять все необходимые вычисления.
    2.  Убрать параметр `overall_stats` из сигнатуры метода `compute` плагинов.
    3.  `StatisticsService` будет отвечать за подготовку нужного среза данных и передачу его в плагины.

#### 2.2. Переход на Инкрементальное Обновление Статистики

*   **Описание проблемы:** После каждого импорта запускается полный пересчет всей статистики, что неэффективно при больших объемах данных.
*   **Цель:** Значительно повысить производительность, обновляя существующие агрегированные значения вместо их полного пересчета.
*   **Задача:**
    1.  Изменить `StatisticsService` так, чтобы при получении события `DataImportedEvent` он не пересчитывал все с нуля.
    2.  Для новых данных сервис должен выполнять SQL-запросы вида `UPDATE overall_stats SET total_buy_in = total_buy_in + ?`, где `?` — это сумма только по новым турнирам. Это требует тщательной реализации, но дает огромный прирост скорости.

### 3. Улучшение Контрактов и Абстракций

#### 3.1. Изоляция бизнес-логики от UI (Паттерн ViewModel)

*   **Описание проблемы:** UI-компоненты, в частности `StatsGrid`, содержат логику вычисления и форматирования данных. Это смешивает отображение и бизнес-логику.
*   **Цель:** Сделать UI "глупым" (Dumb View), отвечающим только за отображение.
*   **Задача:**
    1.  Удалить из `StatsGrid` и других виджетов всю логику расчета и форматирования.
    2.  Ввести `ViewModel` — простые классы-структуры (`dataclass`), содержащие уже готовые для отображения данные (например, `roi_text: str = "+15.2%"`, `profit_color: str = "#10B981"`).
    3.  Фасад `ApplicationService` будет формировать эти `ViewModel` на основе данных от `StatisticsService` и передавать их в UI.

#### 3.2. Стандартизация Контракта и Структуры Парсеров

*   **Описание проблемы:** Логика определения типа файла находится в `ApplicationService`. Парсеры возвращают словари, что менее строго и надежно, чем типизированные объекты.
*   **Цель:** Сделать систему парсинга более структурированной, расширяемой и надежной.
*   **Задача:**
    1.  Создать `parsers/file_classifier.py` с классом `FileClassifier`, который будет отвечать за определение типа файла.
    2.  Изменить метод `parse` у всех парсеров (`HandHistoryParser`, `TournamentSummaryParser`) так, чтобы он всегда возвращал не `dict`, а экземпляры моделей из `models/` (например, `Tuple[Tournament, List[FinalTableHand]]`). Это сделает "контракт" парсера явным.

#### 3.3. Создание Базовых Классов для Репозиториев и Моделей

*   **Описание проблемы:** В репозиториях и моделях есть повторяющийся код для работы с БД и преобразования данных.
*   **Цель:** Устранить дублирование кода (DRY), используя наследование.
*   **Задача:**
    1.  Создать `db/repositories/base_repo.py` с классом `BaseRepository`, содержащим общую логику (например, получение `database_manager`).
    2.  Создать `models/base_model.py` с `BaseModel`, предоставляющим универсальную реализацию `as_dict` и `from_dict`.

---