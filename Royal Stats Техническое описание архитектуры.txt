# Royal Stats Техническое описание архитектуры

## Обзор Архитектуры

Royal Stats построен на принципах многослойной архитектуры с четким разделением ответственности:

### Слои архитектуры:
1. **Presentation Layer (UI)** - уровень взаимодействия с пользователем
2. **Application Logic Layer** - уровень бизнес-логики и координации  
3. **Domain Layer (Models)** - уровень представления данных предметной области
4. **Data Access Layer (Repositories)** - уровень абстракции доступа к данным
5. **Infrastructure Layer** - уровень низкоуровневых компонентов

### Принципы взаимодействия:
- Вышележащие слои могут использовать нижележащие, но не наоборот
- UI → Application Service → Repositories/Parsers → DatabaseManager
- Строгое соблюдение границ между слоями

## Структура Базы Данных (SQLite)

### Основные таблицы:

#### sessions
```sql
id (INTEGER PRIMARY KEY AUTOINCREMENT)
session_id (TEXT UNIQUE NOT NULL)
session_name (TEXT NOT NULL)
created_at (TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
tournaments_count (INTEGER DEFAULT 0)
knockouts_count (INTEGER DEFAULT 0)
avg_finish_place (REAL DEFAULT 0)
total_prize (REAL DEFAULT 0)
total_buy_in (REAL DEFAULT 0)
```
**Назначение**: Хранение метаданных и агрегированной статистики по сессиям импорта.

#### tournaments
```sql
id (INTEGER PRIMARY KEY AUTOINCREMENT)
tournament_id (TEXT UNIQUE NOT NULL)
tournament_name (TEXT)
start_time (TEXT)
buyin (REAL)
payout (REAL)
finish_place (INTEGER)
ko_count (INTEGER DEFAULT 0)
session_id (TEXT, FOREIGN KEY)
reached_final_table (BOOLEAN DEFAULT 0)
final_table_initial_stack_chips (REAL)
final_table_initial_stack_bb (REAL)
```
**Назначение**: Агрегированная информация по турнирам, объединяющая данные из HH и TS.

#### hero_final_table_hands
```sql
id (INTEGER PRIMARY KEY AUTOINCREMENT)
tournament_id (TEXT NOT NULL, FOREIGN KEY)
hand_id (TEXT NOT NULL)
hand_number (INTEGER)
table_size (INTEGER)
bb (REAL)
hero_stack (REAL)
hero_ko_this_hand (INTEGER DEFAULT 0)
session_id (TEXT, FOREIGN KEY)
is_early_final (BOOLEAN DEFAULT 0)
UNIQUE (tournament_id, hand_id)
```
**Назначение**: Детальная информация по раздачам финального стола для точного подсчета KO.

#### overall_stats
```sql
id (INTEGER PRIMARY KEY CHECK (id = 1))
total_tournaments (INTEGER DEFAULT 0)
total_final_tables (INTEGER DEFAULT 0)
total_knockouts (INTEGER DEFAULT 0)
avg_finish_place (REAL DEFAULT 0)
avg_finish_place_ft (REAL DEFAULT 0)
total_prize (REAL DEFAULT 0)
total_buy_in (REAL DEFAULT 0)
avg_ko_per_tournament (REAL DEFAULT 0)
avg_ft_initial_stack_chips (REAL DEFAULT 0)
avg_ft_initial_stack_bb (REAL DEFAULT 0)
big_ko_x1_5, big_ko_x2, big_ko_x10, big_ko_x100, big_ko_x1000, big_ko_x10000 (INTEGER DEFAULT 0)
early_ft_ko_count (INTEGER DEFAULT 0)
early_ft_ko_per_tournament (REAL DEFAULT 0)
last_updated (TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
```
**Назначение**: Кеширование агрегированных статистик для быстрого доступа.

#### places_distribution
```sql
place (INTEGER PRIMARY KEY)
count (INTEGER DEFAULT 0)
```
**Назначение**: Распределение финишных мест на финальном столе (1-9).

## Архитектурные Компоненты

### 1. Application Service (application_service.py)
**Роль**: Центральный координатор и синглтон
**Ответственности**:
- Координация между парсерами, репозиториями и UI
- Управление жизненным циклом данных
- Оркестрация процесса импорта
- Расчет и кеширование статистики
- Управление базами данных

**Ключевые методы**:
- `import_files()` - импорт файлов с прогресс-колбэком
- `_update_all_statistics()` - пересчет всей статистики
- `switch_database()` - переключение между БД
- `get_overall_stats()` - получение агрегированной статистики

### 2. Database Layer

#### DatabaseManager (db/manager.py)
**Роль**: Синглтон для управления соединениями с БД
**Ответственности**:
- Потокобезопасная работа с SQLite
- Переключение активной БД
- Создание схемы при инициализации
- Управление жизненным циклом соединений

#### Repositories (db/repositories/*)
**Компоненты**:
- `TournamentRepository` - CRUD для турниров
- `SessionRepository` - CRUD для сессий
- `OverallStatsRepository` - работа с агрегированной статистикой
- `PlaceDistributionRepository` - распределение мест
- `FinalTableHandRepository` - раздачи финального стола

**Принципы**:
- Содержат только CRUD операции и простые агрегации
- Не содержат бизнес-логики
- Используют DatabaseManager для получения соединений

### 3. Parsers (parsers/*)

#### BaseParser
**Роль**: Базовый класс для всех парсеров
**Функции**:
- Общие методы проверки Hero
- Конфигурация через config.HERO_NAME

#### HandHistoryParser
**Ответственности**:
- Парсинг файлов истории рук (.txt, .hh, .log)
- Извлечение данных о финальном столе
- Подсчет нокаутов по раздачам
- Определение стека Hero на старте финального стола

#### TournamentSummaryParser  
**Ответственности**:
- Парсинг файлов итогов турниров (.ts, .summary)
- Извлечение бай-инов, выплат, финишных мест
- Получение названий и времени турниров

### 4. Models (models/*)
**Компоненты**:
- `Tournament` - модель турнира
- `Session` - модель сессии импорта
- `OverallStats` - агрегированная статистика
- `FinalTableHand` - раздача финального стола

**Принципы**:
- Простые dataclass структуры
- Методы преобразования в/из словаря
- Минимум бизнес-логики

### 5. Statistics Modules (stats/*)

#### Архитектура стат-плагинов:
- `BaseStat` - базовый интерфейс для всех статистик
- Каждая статистика - отдельный класс
- Pluggable архитектура для расширяемости
- Получают данные из ApplicationService

#### Реализованные статистики:
- `TotalKOStat` - общее количество нокаутов
- `ITMStat` - процент попадания в призы
- `ROIStat` - рентабельность инвестиций
- `BigKOStat` - статистика больших нокаутов
- `FinalTableReachStat` - процент достижения финального стола
- `AvgFTInitialStackStat` - средний стек на старте финалки
- `EarlyFTKOStat` - нокауты в ранней стадии финалки
- И другие специализированные статистики

### 6. UI Layer (ui/*)

#### MainWindow
**Роль**: Главное окно приложения
**Функции**:
- Координация всех UI компонентов
- Панель инструментов с быстрой статистикой
- Управление вкладками
- Обработка пользовательских действий

#### Основные UI компоненты:
- `StatsGrid` - сетка статистических карточек и графиков
- `TournamentView` - таблица турниров с фильтрацией
- `SessionView` - просмотр сессий импорта
- `DatabaseManagementDialog` - управление базами данных

#### Background Processing (ui/background.py):
- `ThreadManager` - управление фоновыми задачами
- `ImportThread` - асинхронный импорт файлов
- Поддержка прогресс-индикации и отмены операций

## Потоки Данных

### Процесс импорта файлов:
1. **UI**: Пользователь выбирает файлы/папки
2. **MainWindow**: Создает ImportThread с прогресс-диалогом
3. **ImportThread**: Вызывает ApplicationService.import_files()
4. **ApplicationService**: 
   - Создает новую сессию
   - Классифицирует файлы (HH/TS)
   - Вызывает соответствующие парсеры
   - Объединяет данные по турнирам
   - Сохраняет через репозитории
5. **Пересчет статистики**:
   - Вызывает стат-плагины
   - Обновляет overall_stats и places_distribution
   - Обновляет статистику сессий
6. **UI**: Обновляет отображение данных

### Кеширование и производительность:
- **Трехуровневый кеш статистики**:
  1. Память (ApplicationService._overall_stats_cache)
  2. База данных (overall_stats таблица)
  3. Файл (stats_cache.json)
- **Инкрементальные обновления** статистики
- **Ленивая загрузка** данных в UI вкладках
- **Debounce фильтров** для оптимизации

## Конфигурация (config.py)

### Основные параметры:
- `HERO_NAME` - имя отслеживаемого игрока
- `DEFAULT_DB_DIR` - директория для баз данных
- `FINAL_TABLE_SIZE = 9` - размер финального стола
- `EARLY_FT_MIN_PLAYERS = 6` - граница ранней финалки
- UI настройки (тема, масштаб, язык)

### Файловая структура:
- `databases/` - директория с базами данных
- `last_db_path.txt` - путь к последней БД
- `stats_cache.json` - кеш статистики

## Особенности Реализации

### Многопоточность:
- UI работает в главном потоке
- Импорт и пересчет статистики - в фоновых потоках
- Потокобезопасная работа с базой данных
- Thread pool для множественных операций

### Управление памятью:
- Кеширование часто используемых данных
- Освобождение ресурсов при переключении БД
- Оптимизация SQL запросов

### Расширяемость:
- Плагинная архитектура статистик
- Легкое добавление новых типов парсеров
- Модульная структура UI компонентов

### Отказоустойчивость:
- Валидация данных на всех уровнях
- Graceful degradation при ошибках парсинга
- Откат транзакций при ошибках
- Подробное логирование для диагностики

## Диаграмма архитектуры

```
┌─────────────────────────────────────────────────────────┐
│                    UI LAYER                             │
│  MainWindow │ StatsGrid │ TournamentView │ SessionView  │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              APPLICATION LOGIC                          │
│            ApplicationService (Singleton)               │
└──────────┬──────────────────────────┬───────────────────┘
           │                          │
┌──────────▼──────────┐    ┌──────────▼───────────────────┐
│   DOMAIN LAYER      │    │    INFRASTRUCTURE LAYER     │
│                     │    │                             │
│ • Tournament        │    │ • HandHistoryParser         │
│ • Session           │    │ • TournamentSummaryParser   │
│ • OverallStats      │    │ • DatabaseManager           │
│ • FinalTableHand    │    │ • Background Threads        │
└─────────────────────┘    └─────────────────────────────┘
           │                          │
┌──────────▼──────────────────────────▼───────────────────┐
│                DATA ACCESS LAYER                        │
│        Repository Pattern Implementation                │
│  TournamentRepo │ SessionRepo │ StatsRepo │ HandRepo    │
└─────────────────────────┬───────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────┐
│                  SQLite DATABASE                        │
│  sessions │ tournaments │ hero_final_table_hands │ ...  │
└─────────────────────────────────────────────────────────┘
```

Эта архитектура обеспечивает масштабируемость, тестируемость и поддерживаемость кода при сохранении высокой производительности для пользователя.